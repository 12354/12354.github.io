<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Integration Details - MIDI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Integration Details - MIDI </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="soundengine_midi_intro"></a>
Introduction</h1>
<p>The SDK API provides functions to post MIDI events to the sound engine. The types of MIDI events that may be posted are:</p><ul>
<li>note-on event.</li>
<li>note-off event.</li>
<li>and continuous controller (CC) event.</li>
</ul>
<p>For MIDI events to produce sound they must have a target synthesizer. The synthesizer is a collection of Wwise objects created by the Wwise user in the project's Actor-Mixer hierarchy. Note-on events will typically play the targeted Actor-Mixer object or one of its descendants. If played, the Actor-Mixer object will stop once it has:</p><ul>
<li>reached the end of its source if it is not set to loop,</li>
<li>or a corresponding note-off event (same note and channel) is sent to the same target.</li>
</ul>
<h1><a class="anchor" id="soundengine_midi_integrating"></a>
Integrating MIDI Events in Your Game</h1>
<p>The AK::SoundEngine::PostMIDIOnEvent "PostMIDIOnEvent" function queues MIDI events in the sound engine. The function takes as arguments:</p><ul>
<li>the MIDI event.</li>
<li>an Event ID.</li>
<li>a Game Object ID.</li>
<li>a Playing ID.</li>
</ul>
<p>The sound engine groups posted MIDI events into sequences. Each sequence is identified by the following:</p><ul>
<li>a Game Object ID; a function parameter,</li>
<li>a Playing ID; a function parameter,</li>
<li>a Wwise Object ID; obtained from the target object of each play action in the event corresponding to event ID. See <a class="el" href="integrating_elements_events.html">Integrating Events</a> for more details regarding Events.</li>
</ul>
<p>Thus, it is possible to post the same MIDI event(s) to multiple targets simultaneously. For example, suppose we have:</p><ul>
<li>event EV1, which has play actions for both Wwise Objects W0 and W1,</li>
<li>event EV2, which has a play action for Wwise Object W0.</li>
</ul>
<p>If we post MIDI event ME1 to EV1 with Game Object GO, then the sound engine will add MIDI event ME1 to the MIDI sequences W0-GO-PID1 and W1-GO-PID1, where PID1 is the Playing ID returned by PostMIDIOnEvent. If we then post MIDI event ME2 to event EV2, the sound engine will add MIDI event ME2 to the MIDI sequence W0-GO-PID2.</p>
<p>Calls to AK::SoundEngine::PostMIDIOnEvent add MIDI events to the MIDI sequences. However, no processing is done until the AK::SoundEngine::RenderAudio function has been called. Each call to AK::SoundEngine::RenderAudio processes the message queue, and may produce any number of audio frames; depending on how much time has elapsed since the previous call to RenderAudio. For each frame processed by RenderAudio, the sound engine advances all MIDI sequences by one frame.</p>
<h1><a class="anchor" id="soundengine_midi_event_timing"></a>
MIDI Event Timing</h1>
<p>The moment at which a MIDI event is executed is determined by the following factors:</p><ul>
<li>the moment at which it was queued (via PostMIDIOnEvent),</li>
<li>the event's member AkMIDIPost::uOffset,</li>
<li>the argument in_bAbsoluteOffsets provided to the call to PostMIDIOnEvent.</li>
</ul>
<p>If in_bAbsoluteOffsets is false, the MIDI event is executed uOffset samples from the time the PostMIDIOnEvent message is read from the sound engine's message queue (see Updating MIDI Sequences). If in_bAbsoluteOffsets is true, the MIDI event is executed uOffset samples in absolute time. The current absolute time is obtained via a call to AK::SoundEngine::GetSampleTick.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> The duration of a sample can be determined from the sound engine's audio settings, via a call to AK::SoundEngine::GetAudioSettings. </td></tr>
</table>
<h1><a class="anchor" id="soundengine_midi_event_playing_id"></a>
MIDI Event Sequences - Playing ID</h1>
<p>A call to PostMIDIOnEvent combines all posted MIDI events into a MIDI sequence. As mentioned previously, a MIDI sequence is identified by:</p><ul>
<li>a Playing ID,</li>
<li>a Game Object ID,</li>
<li>an Event ID. A sequence's Playing ID is created by a call to PostMIDIOnEvent with in_playingID set to AK_INVALID_PLAYING_ID. The Playing ID is used in subsequent calls to PostMIDIOnEvent to add MIDI events to the sequence. The sequence is as follows:</li>
<li>A first call to PostMIDIOnEvent creates the MIDI sequence. The function argument in_playingID is set to AK_INVALID_PLAYING_ID. The function returns the Playing ID PID.</li>
<li>A subsequent call to PostMIDIOnEvent is made to add events to the sequence. The function argument in_playingID is set to PID.</li>
</ul>
<p>The Playing ID returned by PostMIDIOnEvent determines if the events were posted to the intended sequence. If the returned Playing ID:</p><ul>
<li>matches in_playingID, then the events were added to the intended sequence.</li>
<li>does not match in_playingID, then the events were added to a newly created sequence.</li>
<li>is AK_INVALID_PLAYING_ID, then an error occurred, and the events were not added to any sequence.</li>
</ul>
<p>A new sequence, different from the one specified, may be created if:</p><ul>
<li>the sequence (Playing ID) did not exist,</li>
<li>the sequence was created using a different Game Object or Event,</li>
<li>the sequence no longer exists because all MIDI events have been executed and all playing sounds have ended.</li>
</ul>
<h1><a class="anchor" id="soundengine_midi_update_sequence"></a>
Updating MIDI Sequences</h1>
<p>It is important that each a MIDI sequence be played by the sound engine at the exact time intended by the application. There are two ways a MIDI sequence may be posted to the sound engine.</p>
<p>If the entire MIDI sequence is known, and it is known that the timing of the MIDI sequence will not change, then the entire MIDI sequence may be posted with one call to AK::SoundEngine::PostMIDIOnEvent.</p>
<p>However if that is not the case, then the MIDI sequence will have to be updated at each frame. The AK::SoundEngine::PostMIDIOnEvent function may be called at any moment, and anywhere in the application. However, calling this function in a thread other than the main audio thread may lead to synchronization issues. Calls to AK::SoundEngine::PostMIDIOnEvent only post the events in the sound engine's message queue. The message queue is processed during a call to AK::SoundEngine::RenderAudio, and such a call may lead to any number of processed audio frames. To ensure proper synchronization, it is recommended that the application register a global callback function as follows:</p>
<ul>
<li>AK::SoundEngine::RegisterGlobalCallback( &amp;MyCallbackFunction, AkGlobalCallbackLocation_PreProcessMessageQueueForRender );</li>
</ul>
<p>The registered function will be called by the sound engine at each audio frame. The application can use the callback function to keep track of audio frames processed by the sound engine. Thus, posting MIDI events in the callback function will ensure proper synchronization.</p>
<h1><a class="anchor" id="soundengine_midi_stop"></a>
Stopping a MIDI Sequence</h1>
<p>Call the AK::SoundEngine::StopMIDIOnEvent "StopMIDIOnEvent" function to stop a MIDI sequence. The function accepts a Playing ID, an Event ID and a Game Object ID as parameters. Any of these parameters can be set to their invalid values to act as wild cards. Thus, if all arguments are set to invalid then all MIDI sequences are stopped.</p>
<p>A call to this function will clear the MIDI sequence(s) and stop any playing sounds.</p>
<p>For examples of integrating MIDI, refer to <a class="el" href="quickstart_sample_integration_midi.html">Quick Start Sample Integration - MIDI</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>

