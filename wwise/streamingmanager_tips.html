<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>I/O Tips, Troubleshooting and Optimization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">I/O Tips, Troubleshooting and Optimization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table border="1" cellspacing="0" cellpadding="5" bgcolor="#a4ecc9">
<tr>
<td><b>Default Streaming Manager Information</b><br  />
<br  />
 The collection of tips and other I/O oriented considerations described in this chapter are only relevant if you use the default implementation of the high-level Stream Manager's API and hook your I/O code below the Low-Level I/O interface. For the most part, understanding of the default Stream Manager's settings (<a class="el" href="streamingmanager_settings.html">Audiokinetic Stream Manager Initialization Settings</a>) and of the Low-Level I/O interface (<a class="el" href="streamingmanager_lowlevel.html">Low-Level I/O</a>) is assumed. </td></tr>
</table>
<h1><a class="anchor" id="streamingmanager_tips_dvddevice"></a>
Tuning Streaming Device Settings</h1>
<p>The default device settings (obtained from <a class="el" href="namespace_a_k_1_1_stream_mgr_a7d01e09a9bb6b6d34c2bb8f4c8995214.html#a7d01e09a9bb6b6d34c2bb8f4c8995214">AK::StreamMgr::GetDefaultDeviceSettings</a>) are appropriate for a DVD device. The default granularity is 16 KB, but larger granularities often result in better DVD throughput <em>for a single stream</em>. 32 KB seems to be a good choice for most DVD drives. Use a larger granularity only if you never stream more than one or two audio files. Otherwise, you might optimize the throughput of a single stream at the expense of others. Also, be aware that a larger granularity requires more stream I/O memory.</p>
<p>If you use the soundengine to load soundbanks from files, it may also be beneficial to modify one of the sound engine initialization settings, <a class="el" href="struct_ak_init_settings_ae4c40fd9bab28527705d43b2247bbe21.html#ae4c40fd9bab28527705d43b2247bbe21" title="The number of bytes read by the BankReader when new data needs to be loaded from disk during serializ...">AkInitSettings::uBankReadBufferSize</a>. This is the amount of data requested at a time when reading in soundbank data from a file. Larger values will issue fewer reads, or fewer sets of reads, at the cost of more memory. This will have no effect if you are loading soundbanks from memory.</p>
<p>At some point, you will probably wish to optimize the memory usage. You may find useful information about this in <a class="el" href="streamingmanager_tips.html#streamingmanager_tips_iomemorypool">Reducing the I/O Pool Memory Usage</a>.</p>
<h2><a class="anchor" id="streamingmanager_tips_deferreddevice_asyncapi"></a>
Game Engine I/O Manager Exposes an Asynchronous API</h2>
<p>If your I/O manager only exposes an asynchronous API and you wish to route the Wwise I/O calls to it, it is much easier for you to implement an adapter layer with a deferred I/O hook. In order to reduce false predictions, typical to the deferred I/O device, set <a class="el" href="struct_ak_device_settings_af49f8b3af816b58296e952b20de2d7a3.html#af49f8b3af816b58296e952b20de2d7a3" title="Maximum number of transfers that can be sent simultaneously to the Low-Level I/O.">AkDeviceSettings::uMaxConcurrentIO</a> to 1 or 2.</p>
<h2><a class="anchor" id="streamingmanager_tips_deferreddevice_shufflerequests"></a>
Game Engine I/O Manager Can Shuffle I/O Requests Based on File Placement</h2>
<p>The Wwise Stream Manager is incapable of taking decisions according to where files are physically located on disk. If your I/O manager can shuffle the pending requests order based on its knowledge of file placement, favoring transfers that are close next to one another for example, it may be more beneficial to receive more transfers from the Wwise Stream Manager at once, and to push them into your own scheduler.</p>
<h2><a class="anchor" id="streamingmanager_tips_deferreddevice_completionindependentfromnumberoftransfers"></a>
Transfer Completion Is Independent From Number of Transfers Issued</h2>
<p>Some devices resolve transfer requests periodically, based on mechanisms that are mostly independent from the number of transfers that are issued. This is often the case with DMA controller-based devices. Transfers are completed when DMA completes, but you don't want to wait until it does before preparing another DMA; in this case, use a deferred device with a large <a class="el" href="struct_ak_device_settings_af49f8b3af816b58296e952b20de2d7a3.html#af49f8b3af816b58296e952b20de2d7a3" title="Maximum number of transfers that can be sent simultaneously to the Low-Level I/O.">AkDeviceSettings::uMaxConcurrentIO</a>. It should be large enough so that it never prevents I/O requests to be sent in to the Low-Level I/O. The amount of bandwidth is therefore solely controlled by the target buffering length.</p>
<h1><a class="anchor" id="streamingmanager_tips_multipledevices"></a>
Using Multiple Devices</h1>
<p>Generally, you should use a different streaming device for each physical device (DVD, HDD, RAM/VRAM, and so on). The first reason is that each streaming device runs in a separate thread, which is mandatory if you don't want transfer requests to be serialized among your physical devices. It would be inefficient to wait for a DVD read before issuing an HDD read. The second reason is that optimal settings are usually different for each device.</p>
<p>When using multiple devices, you need a dispatcher. Refer to <a class="el" href="streamingmanager_lowlevel.html#streamingmanager_lowlevel_default_implementation_walkthrough_multidevice">Multi-Device I/O System</a> for more details on implementing a system with multiple devices.</p>
<p>Dispatching requires that you know which files should be opened from which device. The preferred solution is to use file packages. After generating soundbanks, soundbanks and streamed audio files can be packed together in various file packages using the File Packager. Each file package is meant to be loaded in a specific device. At run-time, a simple dispatcher could query each device until one of them accepts to open the file. This is what the default dispatcher does (see AkDefaultLowLevelIODispatcher.h/cpp in the samples of the SDK). With this technique, you may even implement fallback mechanisms. For example, try to load a file from the RAM/VRAM device, and if it does not work, load it from the DVD.</p>
<p>Note that file dispatching/device assignation must be synchronous: you cannot defer it, so ensure that it is fast. File package look up implemented in the samples of the SDK is fast, because it uses a binary search algorithm.</p>
<h1><a class="anchor" id="streamingmanager_tips_troubleshooting"></a>
Troubleshooting I/O</h1>
<p>Connect the Wwise tool to your game and use the profiler to troubleshoot and optimize your I/O system and settings. The capture log informs you of source starvations and other I/O errors. The two tabs of the Advanced Profiler view are solely dedicated to I/O: the Streams tab and the Streaming Devices tab.</p>
<h2><a class="anchor" id="streamingmanager_tips_troubleshooting_sourcestarvation"></a>
Troubleshooting Source Starvation</h2>
<p>Source (I/O) starvation occurs whenever streaming data was not sent to the Stream Manager within the required deadline. An error notification appears in the capture log of the profiler, along with the name/ID of the starving audio source.</p>
<h3><a class="anchor" id="streamingmanager_tips_troubleshooting_sourcestarvation_causes"></a>
Causes of Source Starvation</h3>
<p>Source starvation may not be caused by bad I/O settings, but for other reasons instead:</p>
<p>1) Interactive music: Streaming objects of the Interactive Music hierarchy are scheduled ahead of time, and require that streaming data be ready on time. This look-ahead time is a property of each music track. If starvation occurs with interactive music, it may be because the look-ahead time you have specified is not large enough.</p>
<p>2) Zero-latency streaming: If you check the "Zero Latency" option in sounds and music tracks properties, the beginning of the streaming file is stored into soundbanks. When you post an event to play them, they start playing immediately, using the data that was stored in the soundbank (prefetched data). But if they run out of prefetched data before the following part of their file has been streamed from disk, source starvation occurs. In such a case, increase the prefetch length.</p>
<p>Sounds of the actor-mixer hierarchy that are not marked as "Zero-Latency" never start playing before their target buffering length is reached. The time it takes to reach the target buffering constitutes the initial latency of the sound. So if starvation occurs with these sounds, it is probably due to improper or unbalanced I/O conditions.</p>
<h3><a class="anchor" id="streamingmanager_tips_troubleshooting_sourcestarvation_memory"></a>
Insufficient I/O Memory</h3>
<p>Apart from asking more throughput than your device can provide, the main cause of starvation is to run out of I/O memory. When the I/O memory pool is full, the streaming device stops sending transfer requests to the low-level I/O. Check the I/O memory usage in the Streaming Devices tab of the profiler.</p>
<h3><a class="anchor" id="streamingmanager_tips_troubleshooting_sourcestarvation_workload"></a>
Excessive Workload</h3>
<p>If source starvation is generalized in some situations, and is not specific to some streams, it may be because you are asking too much audio data than what your I/O device can provide. Don't forget that you need to share its bandwidth with other assets of the game. The preferred way of limiting the burden of audio on I/O is to limit the number of streams using the data-driven features of Wwise, like instance limiting and virtual voices.</p>
<p>Starvation may also be caused if your target buffering is too small. In the Streams tab, pay attention to the Buffering Status and the amount of referenced memory (Ref. Memory). If the Buffering Status bar is gray most of the time (that is, it meets the target), but the referenced memory often drops to 0, it probably means that your target buffering is too small: the I/O thread is mostly idle, but buffering is insufficient to make up for the time it takes to read a buffer from disk once the I/O scheduler decided to post an I/O request.</p>
<p>On the other hand, if the Buffering Status bar is orange or blue (depending on the theme) for streams that should be in steady state (that is, that have already started playing), it means that the low-level I/O device is too slow to service them. Note that it could also be because there is no more available memory in the I/O pool (check the Streaming Devices tab), or because the scheduler is waiting for the concurrent I/O request count to drop below <a class="el" href="struct_ak_device_settings_af49f8b3af816b58296e952b20de2d7a3.html#af49f8b3af816b58296e952b20de2d7a3" title="Maximum number of transfers that can be sent simultaneously to the Low-Level I/O.">AkDeviceSettings::uMaxConcurrentIO</a>.</p>
<h3><a class="anchor" id="streamingmanager_tips_troubleshooting_sourcestarvation_other"></a>
Starvation Occurring Systematically in the Presence of Certain Streams</h3>
<p>Sometimes, source starvation may occur systematically in the presence of certain streams.</p>
<p>The total throughput required for a streaming device to correctly service all audio streams is balanced between them using heuristics based on their compression format, sample rate, number of channels, and so on. However, some variable bitrate codecs (like XMA and Vorbis) sometimes pull more I/O data that they initially declared, during seeking for example, and sometimes also at loop boundaries. If this occurs with seeking, try using a smaller seek table block size in the conversion settings. Note that seeking also occurs in interactive music and with the "From Elapsed Time" virtual voice behavior.</p>
<p>Otherwise, it can also be caused by a file being far away on disk. Use the platform's tools (or the File Packager utility if you use file packages) to optimize file placement on disk by minimizing seeks at run-time.</p>
<p>You may also compensate for these throughput requirement spikes by increasing the target buffering length (but watch out for increased I/O memory usage).</p>
<h3><a class="anchor" id="streamingmanager_tips_troubleshooting_sourcestarvation_moretips"></a>
More Tips</h3>
<p>If you stream small looping sounds, it may be useful to enable caching (<a class="el" href="struct_ak_device_settings_aaa0e8dc2b18f827559aaf8672705dd49.html#aaa0e8dc2b18f827559aaf8672705dd49" title="If true, the device attempts to reuse I/O buffers that have already been streamed from disk....">AkDeviceSettings::bUseStreamCache</a>). This will help save bandwidth and I/O memory.</p>
<p>Also, avoid wasting bandwidth with DVD/HDD devices. If you use a deferred device, watch for cancelled transfers (in the Streaming Devices tab of the profiler). Reducing the maximum number of concurrent transfers (<a class="el" href="struct_ak_device_settings_af49f8b3af816b58296e952b20de2d7a3.html#af49f8b3af816b58296e952b20de2d7a3" title="Maximum number of transfers that can be sent simultaneously to the Low-Level I/O.">AkDeviceSettings::uMaxConcurrentIO</a>) should help.</p>
<h2><a class="anchor" id="streamingmanager_tips_troubleshooting_voicestarvation"></a>
Reducing CPU Usage by the I/O Thread</h2>
<p>Threads of I/O devices usually use an insignificant amount of CPU, as they spend most of their time waiting for I/O. This CPU usage may be more significant with very fast devices (like RAM devices). In such a case, you can</p><ul>
<li>Decrease target buffering;</li>
<li>Decrease thread priority.</li>
</ul>
<p>If CPU spikes occur only when opening files, it may be because file opening takes a significant amount of time. Some platforms/disk devices are slow to return from fopen(). In such a case, defer file open (refer to <a class="el" href="streamingmanager_lowlevel.html#streamingmanager_lowlevel_location_deferred_open">Deferred Opening</a> for more details).</p>
<h2><a class="anchor" id="streamingmanager_tips_iomemorypool"></a>
Reducing the I/O Pool Memory Usage</h2>
<p>Apart from reducing the number of streams playing concurrently, you may reduce the size of I/O memory required by</p><ul>
<li>Lowering the granularity (beware of negative impacts on device throughput);</li>
<li>Lowering the target buffering (beware of source starvation);</li>
<li>Using stream data caching (on the other hand, note that caching is less efficient with smaller pools).</li>
</ul>
<p>Note that fragmentation never occurs in the I/O memory pool. Also, it is acceptable to run out of memory sporadically in this pool. Often, data that has been already streamed in is sufficient to sustain this spike in memory usage. The worst that can occur is source starvation.</p>
<h2><a class="anchor" id="streamingmanager_tips_streammgrmemorypool"></a>
Reducing the Stream Manager Pool Memory Usage</h2>
<p>The Stream Manager memory pool is used for small object allocations: device and stream objects, transfer structures, storage for asynchronous file opening, stream memory look-up tables, and so on. The typical size required for this pool is quite small, but ideally, ensure that you never run out of memory in this pool. This would provoke unrecoverable I/O failures. Note that most of it is allocated when devices are created.</p>
<p>The following settings will decrease the memory required from the Stream Manager pool:</p><ul>
<li>Use a blocking device instead of a deferred device;</li>
<li>If you use a deferred device, decrease the maximum number of concurrent requests (<a class="el" href="struct_ak_device_settings_af49f8b3af816b58296e952b20de2d7a3.html#af49f8b3af816b58296e952b20de2d7a3" title="Maximum number of transfers that can be sent simultaneously to the Low-Level I/O.">AkDeviceSettings::uMaxConcurrentIO</a>);</li>
<li>Disable the stream cache (<a class="el" href="struct_ak_device_settings_aaa0e8dc2b18f827559aaf8672705dd49.html#aaa0e8dc2b18f827559aaf8672705dd49" title="If true, the device attempts to reuse I/O buffers that have already been streamed from disk....">AkDeviceSettings::bUseStreamCache</a>);</li>
<li>Execute synchronous file opens (refer to <a class="el" href="streamingmanager_lowlevel.html#streamingmanager_lowlevel_location_deferred_open">Deferred Opening</a> for more details);</li>
<li>Limit the number of streams opened at the same time. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
