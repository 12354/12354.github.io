<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Creating Sound Engine Effect Plug-ins</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Creating Sound Engine Effect Plug-ins </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="se_insert_effect"></a>
Implementing an Effect Plug-in Interface</h1>
<p>Effect plug-ins apply DSP algorithms to existing sounds fed as input audio data. Writing effect plug-ins consists of implementing one of the <a class="el" href="class_a_k_1_1_i_ak_in_place_effect_plugin.html" title="Software effect plug-in interface for in-place processing (see Creating Sound Engine Effect Plug-ins)...">AK::IAkInPlaceEffectPlugin</a> or <a class="el" href="class_a_k_1_1_i_ak_out_of_place_effect_plugin.html" title="Software effect plug-in interface for out-of-place processing (see Creating Sound Engine Effect Plug-...">AK::IAkOutOfPlaceEffectPlugin</a> interfaces. Only the functions specific to these interface are covered here. Refer to <a class="el" href="soundengine_plugins.html">Creating Sound Engine Plug-ins</a>, for information about interface components shared with other plug-in types (<a class="el" href="class_a_k_1_1_i_ak_plugin.html">AK::IAkPlugin</a> interface). Also refer to the provided AkDelay plug-in for details (<a class="el" href="samplecode.html">Samples</a>).</p>
<h2><a class="anchor" id="iakmonadiceffect_init"></a>
AK::IAkEffectPlugin::Init()</h2>
<p>This method prepares the effect plug-in for data processing, allocates memory, and sets up initial conditions.</p>
<p>The plug-in is passed in a pointer to a memory allocator interface (<code><a class="el" href="class_a_k_1_1_i_ak_plugin_mem_alloc.html">AK::IAkPluginMemAlloc</a></code>). We recommend that you allocate all dynamic memory through this interface using the provided memory allocation macros (refer to <a class="el" href="soundengine_plugins.html#fx_memory_alloc">Allocating/De-allocating Memory in Audio Plug-ins</a>) so that Wwise can track the memory, and so that any underlying memory hooks in the game engine can use it. For the most common memory allocation needs, specifically allocation at initialization and release at termination, the plug-in does not need to retain a pointer to the allocator. It is also provided to the plug-in on termination.</p>
<p>The <code><a class="el" href="class_a_k_1_1_i_ak_effect_plugin_context.html">AK::IAkEffectPluginContext</a></code> interface can access the global context through <code><a class="el" href="class_a_k_1_1_i_ak_plugin_context_base_af02337aeaffd800ffce912a6c4231e0f.html#af02337aeaffd800ffce912a6c4231e0f">AK::IAkPluginContextBase::GlobalContext()</a></code>.</p>
<p>The plug-in also receives a pointer to its associated parameter node interface (<code><a class="el" href="class_a_k_1_1_i_ak_plugin_param.html">AK::IAkPluginParam</a></code>). Most plug-ins keep a reference to the associated parameter node to be able to retrieve parameters at runtime. Refer to <a class="el" href="soundengine_plugins.html#iakeffectparam_communication">Communication Between Parameter Nodes and Plug-ins.</a> for more details.</p>
<p>All of these interfaces remain valid throughout the plug-in's lifespan so it is safe to keep an internal reference to them when necessary.</p>
<p>Effect plug-ins also receive the input/output audio format (which stays the same during the lifespan of the plug-in) to be able to allocate memory and set up processing for a given channel configuration.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> <code><a class="el" href="class_a_k_1_1_i_ak_effect_plugin_ae5a44837c4adddf6ff58fab57453b020.html#ae5a44837c4adddf6ff58fab57453b020">AK::IAkEffectPlugin::Init()</a></code> is called every time the effect is instantiated, which happens when a voice starts playing or a mixing bus is instantiated. Because other sounds are typically playing already, this must occur within a reasonable amount of time. If you need to initialize large common/global data structures, do so when registering the plug-in library. See <a class="el" href="soundengine_plugins.html#fx_global_hooks">Using Global Sound Engine Callbacks From Plug-ins</a> for more details. </td></tr>
</table>
<h2><a class="anchor" id="iakmonadiceffect_execute"></a>
AK::IAkPluginEffect::Execute()</h2>
<p>Effect plug-ins may choose to implement one of 2 interfaces: <a class="el" href="class_a_k_1_1_i_ak_in_place_effect_plugin.html" title="Software effect plug-in interface for in-place processing (see Creating Sound Engine Effect Plug-ins)...">AK::IAkInPlaceEffectPlugin</a> or <a class="el" href="class_a_k_1_1_i_ak_out_of_place_effect_plugin.html" title="Software effect plug-in interface for out-of-place processing (see Creating Sound Engine Effect Plug-...">AK::IAkOutOfPlaceEffectPlugin</a>. In general in-place effects (which use the same audio buffer for both input and output data), should be used for most effects. However, when there is a change in data flow (e.g. time-stretching effect), the out-of-place interface must be implemented instead.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> Out-of-place effects that have different input/output channel configurations can be inserted in the Master-Mixer hierarchy. However, it is not possible to put rate-changing effects on mixing busses. Effects that have different input/output buffer lengths can only be inserted in the Actor-Mixer hierarchy (as source effects). </td></tr>
</table>
<h2><a class="anchor" id="iakmonadiceffect_execute_general"></a>
IAkInPlaceEffectPlugin::Execute</h2>
<p>This method executes the plug-in's signal processing algorithm in-place on a given audio buffer (refer to <a class="el" href="soundengine_plugins.html#fx_audiobuffer_struct">Accessing Data Using AkAudioBuffer Structure</a> for more information). This structure provides information to the plug-in regarding how many input samples are valid (<a class="el" href="class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd" title="Number of valid sample frames in the audio buffer.">AkAudioBuffer::uValidFrames</a>) and the maximum number of audio sample frames the buffer can accommodate (<a class="el" href="class_ak_audio_buffer_a537445dce6e3ed09dd2c337fd73c6b41.html#a537445dce6e3ed09dd2c337fd73c6b41">AkAudioBuffer::MaxFrames()</a> method). The <a class="el" href="class_ak_audio_buffer_a069d15381980ac4851216e084cf6a0cc.html#a069d15381980ac4851216e084cf6a0cc" title="Execution status.">AkAudioBuffer::eState</a> structure member signals the plug-in whether it is the last execution (AK_NoMoreData) or not (AK_DataReady).</p>
<p><a class="el" href="class_a_k_1_1_i_ak_in_place_effect_plugin_afc80cd74cb7eb9673f49443d0838a941.html#afc80cd74cb7eb9673f49443d0838a941">AK::IAkInPlaceEffectPlugin::TimeSkip()</a> is substituted to Execute() when a virtual voice is playing from elapsed time to allow plug-ins to keep updating their internal state if desired.</p>
<h2><a class="anchor" id="iakmonadiceffect_execute_outofplace"></a>
IAkOutOfPlaceEffectPlugin::Execute</h2>
<p>This method executes the plug-in's signal processing for out-of-place algorithms. Two <a class="el" href="class_ak_audio_buffer.html">AkAudioBuffer</a> structure are used, one for the input buffer and one for the output buffer. The pipeline uses the eState in the output audio buffer to determine the current state of the effect. The effect should only return when it has either consumed all of the input buffer (and return AK_DataNeeded to carry on with execution with more data later) or output AK_DataReady when a full output buffer has been filled. Effect tails can also be implemented in out-of-place effect by changing the AK_NoMoreData received by AK_DataReady until the effect has finished flushing its internal state (at which point AK_NoMoreData should be returned).</p>
<p>The input buffer is not released by the pipeline until it is entirely consumed. Therefore, it is important to use the in_uInOffset offset parameter to start reading the data where the last Execute() call left off. The sample below provides an example of how to achieve this.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CAkSimpleUpsampler::Execute(   </div>
<div class="line">        <a class="code" href="class_ak_audio_buffer.html">AkAudioBuffer</a> * io_pInBuffer, </div>
<div class="line">        <a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a>        in_uInOffset,</div>
<div class="line">        <a class="code" href="class_ak_audio_buffer.html">AkAudioBuffer</a> * io_pOutBuffer )</div>
<div class="line">{</div>
<div class="line">    assert( io_pInBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f">NumChannels</a>() == io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f">NumChannels</a>() );</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a> uNumChannels = io_pInBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f">NumChannels</a>();</div>
<div class="line">    <a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a> uFramesConsumed; <span class="comment">// Track how much data is consumed from input buffer</span></div>
<div class="line">    <a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a> uFramesProduced; <span class="comment">// Track how much data is produced to output buffer</span></div>
<div class="line">    <span class="keywordflow">for</span> ( <a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a> i = 0; i &lt; uNumChannels; i++ )</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98">AkReal32</a> * <a class="code" href="_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf">AK_RESTRICT</a> pInBuf = (<a class="code" href="_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98">AkReal32</a> * <a class="code" href="_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf">AK_RESTRICT</a>) io_pInBuffer-&gt;<a class="code" href="class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c">GetChannel</a>( i ) + in_uInOffset; </div>
<div class="line">        <a class="code" href="_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98">AkReal32</a> * <a class="code" href="_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf">AK_RESTRICT</a> pfOutBuf = (<a class="code" href="_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98">AkReal32</a> * <a class="code" href="_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf">AK_RESTRICT</a>) io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c">GetChannel</a>( i ) + io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd">uValidFrames</a>;</div>
<div class="line">        uFramesConsumed = 0; <span class="comment">// Reset for every channel</span></div>
<div class="line">        uFramesProduced = 0; </div>
<div class="line">        <span class="keywordflow">while</span> ( (uFramesConsumed &lt; io_pInBuffer-&gt;uValidFrames) &amp;&amp; (uFramesProduced &lt; io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a537445dce6e3ed09dd2c337fd73c6b41.html#a537445dce6e3ed09dd2c337fd73c6b41">MaxFrames</a>()) )</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Do some processing that consumes input and produces output at different rate (e.g. time-stretch or resampling)</span></div>
<div class="line">             *pfOutBuf++ = *pInBuf;</div>
<div class="line">             *pfOutBuf++ = *pInBuf++;</div>
<div class="line">            uFramesConsumed++;</div>
<div class="line">            uFramesProduced += 2;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Update AkAudioBuffer structure to continue processing</span></div>
<div class="line">    io_pInBuffer-&gt;<a class="code" href="class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd">uValidFrames</a> -= uFramesConsumed;</div>
<div class="line">    io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd">uValidFrames</a> += uFramesProduced;</div>
<div class="line">    <span class="keywordflow">if</span> ( io_pInBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a069d15381980ac4851216e084cf6a0cc.html#a069d15381980ac4851216e084cf6a0cc">eState</a> == <a class="code" href="_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a94ba10d374d31161770fc490e0245802">AK_NoMoreData</a> &amp;&amp; io_pInBuffer-&gt;<a class="code" href="class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd">uValidFrames</a> == 0 )</div>
<div class="line">        io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a069d15381980ac4851216e084cf6a0cc.html#a069d15381980ac4851216e084cf6a0cc">eState</a> = <a class="code" href="_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a94ba10d374d31161770fc490e0245802">AK_NoMoreData</a>; <span class="comment">// Input entirely consumed and nothing more to output, the effect is done</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd">uValidFrames</a> == io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a537445dce6e3ed09dd2c337fd73c6b41.html#a537445dce6e3ed09dd2c337fd73c6b41">MaxFrames</a>() )</div>
<div class="line">        io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a069d15381980ac4851216e084cf6a0cc.html#a069d15381980ac4851216e084cf6a0cc">eState</a> = <a class="code" href="_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a42844243c26095d10ade29e0f020ee0f">AK_DataReady</a>; <span class="comment">// A complete audio buffer is ready</span></div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        io_pOutBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a069d15381980ac4851216e084cf6a0cc.html#a069d15381980ac4851216e084cf6a0cc">eState</a> = <a class="code" href="_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a4fe083d45ca70a624eeb67bf3a14b442">AK_DataNeeded</a>; <span class="comment">// We need more data to continue processing</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="class_a_k_1_1_i_ak_out_of_place_effect_plugin_a8727a7d95bca7d9a5a7ec21a934d7fb9.html#a8727a7d95bca7d9a5a7ec21a934d7fb9">AK::IAkOutOfPlaceEffectPlugin::TimeSkip()</a> is substituted to Execute() when a virtual voice is playing from elapsed time to allow plug-ins to keep updating their internal state if desired. This function is then responsible to tell the pipeline how many input samples would normally be consumed to produce a given number of output frames.</p>
<h2><a class="anchor" id="fx_tails"></a>
Implementing Effect Plug-in Tails</h2>
<p>Some effects have an internal state that must be output after the input is finished playing to decay out properly (most notably effects with delay lines). The effect API makes it possible to continue the execution even without any valid input data. When the eState flag of the <a class="el" href="class_ak_audio_buffer.html">AkAudioBuffer</a> structure becomes AK_NoMoreData, the pipeline will no longer feed valid incoming sample frames to the plug-in after the current execution. The plug-in is then free to write new (subsequent) frames in the buffer (up to the value returned by MaxFrames()) to allow emptying delay lines after the input signal is finished. The audio pipeline should always be told how many frames have been output by properly updating the uValidFrames field. If the plug-in Execute() function needs to be called again to finish flushing the effect tail, the eState member should be set to AK_DataReady. The pipeline will stop calling the plug-in Execute() only when the effect has set AK_NoMoreData for the eState field.</p>
<p>The easiest way to handle tails is to use the <a class="el" href="class_ak_f_x_tail_handler.html">AkFXTailHandler</a> service class provided in the SDK. With an instance of the <a class="el" href="class_ak_f_x_tail_handler.html">AkFXTailHandler</a> held as a class member for your plug-in, all you need to do within an in-place effect is to call <a class="el" href="class_ak_f_x_tail_handler_a3a33b37c47bbcda9fdaac7294cba3bcd.html#a3a33b37c47bbcda9fdaac7294cba3bcd" title="Handle FX tail and zero pads AkAudioBuffer if necessary.">AkFXTailHandler::HandleTail()</a> and pass it the <a class="el" href="class_ak_audio_buffer.html">AkAudioBuffer</a> and the total number of audio samples to output once the output will be finished (which may change from one execution to the other based on a parameter). Refer to the AkDelay plugin source code for details (<a class="el" href="samplecode.html">Samples</a>).</p>
<p><a class="anchor" id="iakeffectplugin_execnotes"></a></p><table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><p class="starttd"><b>Note:</b> <b>Important Notes for Executing Effect Plug-ins</b></p>
<ul>
<li>When a plug-in is used in Wwise, parameter changes are sent down to the parameter node whether or not the parameter supports RTPCs. This allows the plug-in to support runtime value changes of non-RTPC values if desired for Wwise usage. If you do not want your plug-in to support this, you should make a copy of the parameter values at initialization time to ensure they remain the same throughout the plug-in's duration.</li>
<li>A plug-in should handle several channel configurations (at least mono, stereo and 5.1 if it can be inserted on busses) or return AK_UnsupportedChannelConfig at inialization time. </li>
</ul>
</td></tr>
</table>
<h2><a class="anchor" id="fx_bypass"></a>
Bypass</h2>
<p>Plug-ins can be bypassed in Wwise or in-game through various mechanisms, including UI, events, and RTPCs. In such cases, the plug-in Execute() routine is not called. When the plug-in resumes on unbypass and the execute function is called again, the plug-in will restart its processing. The <a class="el" href="namespace_a_k_1_1_comm_af3d99fab833c0b3c4bc7ce7b78d7b4bf.html#af3d99fab833c0b3c4bc7ce7b78d7b4bf">Reset()</a> function of the plug-in is called on bypass so that its delay line and other state information can be cleared for a fresh new start when the effect is finally unbypassed. Refer to <a class="el" href="soundengine_plugins.html#iakeffect_reset">AK::IAkPlugin::Reset()</a> for more information.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> Bypassing and unbypassing plug-ins at runtime may result in signal discontinuities depending on the plug-in and on the sound material being processed. </td></tr>
</table>
<p>For more information, refer to the following sections:</p>
<ul>
<li><a class="el" href="soundengine_plugins.html#se_plugins_overview">Sound Engine Plug-ins Overview</a></li>
<li><a class="el" href="soundengine_plugins_source.html#se_source_effect">Source Plug-in Interface Implementation</a></li>
<li><a class="el" href="effectpluginwwise.html">Writing the Authoring Part of an Audio Plug-in</a></li>
</ul>
<h2><a class="anchor" id="fx_postmonitordata"></a>
Monitoring in the Sound Engine</h2>
<p>Monitoring is the process of observing the state of an audio plug-in during its playback.</p>
<p>When the Authoring application is connected through the communication module, Sound Engine plug-in instances have the opportunity to provide their state as an arbitrary buffer of data that is passed to the Authoring side of the plug-in. This data could be performance metrics computed from the execution process or signal levels at different processing stages for metering purposes.</p>
<p>This section covers the Sound Engine side of monitoring. Refer to the <a class="el" href="wwiseplugin_frontend.html#wwiseplugin_dll_notifymonitordata">Monitoring in Authoring</a> for details on the receiving and deserialization process.</p>
<p><b>Sending Monitoring Data</b></p>
<p>Sending is done by the Sound Engine part of the plug-in. Here are the steps of this process:</p>
<ul>
<li><b>Serialization</b>: Because the monitoring data is provided as a buffer of arbitrary size, the Sound Engine part of the plug-in must serialize the data it wishes to send and its Authoring side counterpart must deserialize it upon reception. Serialization is left to the plug-in maker to implement and the data remains opaque to Wwise. Make sure to use types that have a standard size across platforms, e.g., the size of <code>long</code> varies across 64-bit platforms where some use 4 bytes (LLP64) and others 8 bytes (LP64). Also, be aware that platforms with different alignment requirements may lead to different <code>struct</code> layouts due to the packing strategy. You may specify a custom packing alignment by using the <code>pack</code> pragma.</li>
<li><b>Sending</b>: Once the monitoring data is serialized into a buffer, the Sound Engine plug-in uses the function <code><a class="el" href="class_a_k_1_1_i_ak_plugin_context_base_a417bd7aecedf5ed80a47615f053694d1.html#a417bd7aecedf5ed80a47615f053694d1">AK::IAkPluginContextBase::PostMonitorData()</a></code> provided by its plug-in context instance to send the data through the profiler communication channel. This function should be called inside the <code>Execute</code> function.</li>
</ul>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> Because monitoring data is sent asynchronously, <code><a class="el" href="class_a_k_1_1_i_ak_plugin_context_base_a417bd7aecedf5ed80a47615f053694d1.html#a417bd7aecedf5ed80a47615f053694d1">AK::IAkPluginContextBase::PostMonitorData()</a></code> copies the buffer the Sound Engine plug-in provides. This means that the buffer can safely be allocated on the stack, or otherwise freed after <code>PostMonitorData</code> has been called. </td></tr>
</table>
<p>It is not always possible to send monitoring data: only when the Wwise Authoring application is profiling can the monitoring data be used. Preparing and sending this data in cases when the Authoring is not actively profiling or when the game simply cannot be profiled is wasteful. There are two ways to avoid this cost when not necessary:</p>
<ul>
<li><b>Runtime check</b>: The plug-in context provides the function <code><a class="el" href="class_a_k_1_1_i_ak_plugin_context_base_a5b687dfb16b2a2103a0f7f1c636d6433.html#a5b687dfb16b2a2103a0f7f1c636d6433">AK::IAkPluginContextBase::CanPostMonitorData()</a></code> that will return false when profiling is not active or in any cases where posting monitor data is not supported. Always check whether monitoring is supported using this function prior to calling <code><a class="el" href="class_a_k_1_1_i_ak_plugin_context_base_a417bd7aecedf5ed80a47615f053694d1.html#a417bd7aecedf5ed80a47615f053694d1">AK::IAkPluginContextBase::PostMonitorData()</a></code>.</li>
<li><b>Compile-time check</b>: In release builds, the communication module is typically not initialized, so profiling is not possible. You may remove from compilation the section of code preparing and sending the monitoring data by using a preprocessor check on <code>AK_OPTIMIZED</code>. <code>AK_OPTIMIZED</code> is defined by default for release builds when using the Wwise Plug-in development tool <code>wp.py</code>.</li>
</ul>
<p>The following code example shows how to serialize and send monitoring data:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyPlugin::Execute( <a class="code" href="class_ak_audio_buffer.html">AkAudioBuffer</a> * io_pBuffer )</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a> uNumChannels = io_pBuffer-&gt;<a class="code" href="class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f">NumChannels</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Algorithm tracks signal peaks for all uNumChannels channels inside the following array</span></div>
<div class="line">    <span class="keywordtype">float</span> fChannelPeaks[MAX_NUM_CHANNELS];</div>
<div class="line">    ...</div>
<div class="line">#ifndef AK_OPTIMIZED <span class="comment">// Compile-time check</span></div>
<div class="line">    <span class="keywordflow">if</span> ( m_pContext-&gt;CanPostMonitorData() ) <span class="comment">// Runtime check, m_pContext is cached from MyPlugin::Init()</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// == Serialization</span></div>
<div class="line">        <span class="comment">// Compute the buffer size and allocate a buffer</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uMonitorDataSize = <span class="keyword">sizeof</span>(<a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a>) * uNumChannels*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>);</div>
<div class="line">        <span class="keywordtype">char</span> * pMonitorData = (<span class="keywordtype">char</span> *) <a class="code" href="_win32_2_ak_platform_funcs_8h_aae886a30b939ee13e0abf036fa9e6a15.html#aae886a30b939ee13e0abf036fa9e6a15">AkAlloca</a>( uMonitorDataSize );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Fill the monitoring data buffer</span></div>
<div class="line">         *((<a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a> *) pMonitorData ) = uNumChannels;</div>
<div class="line">        memcpy( pMonitorData + <span class="keyword">sizeof</span>(<a class="code" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a>), fChannelPeaks, uNumChannels*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// == Sending</span></div>
<div class="line">        m_pContext-&gt;PostMonitorData( pMonitorData, uMonitorDataSize );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If the buffer was allocated using \c AK::IAkPluginMemAlloc, free it here</span></div>
<div class="line">        <span class="comment">// When using AkAlloca, nothing to do: the memory is freed automatically when the function returns</span></div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Object processors are a derivative of audio plug-ins that explicitly handle in their <code>Execute</code> function an array of distinct audio signals, each belonging to individual objects. Rather than a single <code><a class="el" href="class_ak_audio_buffer.html">AkAudioBuffer</a></code> instance, <code>Execute</code> receives an <code>Ak3DAudioObjects</code> wrapper object that owns a list of <code><a class="el" href="class_ak_audio_buffer.html">AkAudioBuffer</a></code> instances, one per object.</p>
<p>Because a single object processor plug-in processes an array of audio buffers, monitoring data this plug-in sends must encompass an aggregation of the monitoring data related to all the objects it is processing. The simplest approach is to send the number of objects and serialize the monitoring data related to each signal as an array.</p>
<p>For more on object processors, refer to <a class="el" href="soundengine_plugins_objectprocessor.html">Creating Sound Engine Object Processor Plug-ins</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclass_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c_html_ad2bc3b8ddd61eaa0c111798d5f9e8c9c"><div class="ttname"><a href="class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c">AkAudioBuffer::GetChannel</a></div><div class="ttdeci">AkSampleType * GetChannel(AkUInt32 in_uIndex)</div><div class="ttdef"><b>Definition:</b> <a href="_ak_common_defs_8h_source.html#l00574">AkCommonDefs.h:574</a></div></div>
<div class="ttc" id="a_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63_html_a64f7d1f79613cc4dcc49a4efba6caa63a42844243c26095d10ade29e0f020ee0f"><div class="ttname"><a href="_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a42844243c26095d10ade29e0f020ee0f">AK_DataReady</a></div><div class="ttdeci">@ AK_DataReady</div><div class="ttdoc">The provider has available data.</div><div class="ttdef"><b>Definition:</b> <a href="_common_2_ak_types_8h_source.html#l00241">AkTypes.h:241</a></div></div>
<div class="ttc" id="aclass_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f_html_a4523322478ec9a0f9de0c7c72e65df2f"><div class="ttname"><a href="class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f">AkAudioBuffer::NumChannels</a></div><div class="ttdeci">AkForceInline AkUInt32 NumChannels() const</div><div class="ttdoc">Get the number of channels.</div><div class="ttdef"><b>Definition:</b> <a href="_ak_common_defs_8h_source.html#l00490">AkCommonDefs.h:490</a></div></div>
<div class="ttc" id="a_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63_html_a64f7d1f79613cc4dcc49a4efba6caa63a94ba10d374d31161770fc490e0245802"><div class="ttname"><a href="_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a94ba10d374d31161770fc490e0245802">AK_NoMoreData</a></div><div class="ttdeci">@ AK_NoMoreData</div><div class="ttdoc">No more data is available from the source.</div><div class="ttdef"><b>Definition:</b> <a href="_common_2_ak_types_8h_source.html#l00226">AkTypes.h:226</a></div></div>
<div class="ttc" id="a_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98_html_afc38459f26e2b23defe588026e886a98"><div class="ttname"><a href="_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98">AkReal32</a></div><div class="ttdeci">float AkReal32</div><div class="ttdoc">32-bit floating point</div><div class="ttdef"><b>Definition:</b> <a href="_ak_numeral_types_8h_source.html#l00046">AkNumeralTypes.h:46</a></div></div>
<div class="ttc" id="aclass_ak_audio_buffer_a069d15381980ac4851216e084cf6a0cc_html_a069d15381980ac4851216e084cf6a0cc"><div class="ttname"><a href="class_ak_audio_buffer_a069d15381980ac4851216e084cf6a0cc.html#a069d15381980ac4851216e084cf6a0cc">AkAudioBuffer::eState</a></div><div class="ttdeci">AKRESULT eState</div><div class="ttdoc">Execution status.</div><div class="ttdef"><b>Definition:</b> <a href="_ak_common_defs_8h_source.html#l00649">AkCommonDefs.h:649</a></div></div>
<div class="ttc" id="aclass_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd_html_ab7f90fd99119b56e92e4cbf3559f98cd"><div class="ttname"><a href="class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd">AkAudioBuffer::uValidFrames</a></div><div class="ttdeci">AkUInt16 uValidFrames</div><div class="ttdoc">Number of valid sample frames in the audio buffer.</div><div class="ttdef"><b>Definition:</b> <a href="_ak_common_defs_8h_source.html#l00655">AkCommonDefs.h:655</a></div></div>
<div class="ttc" id="a_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63_html_a64f7d1f79613cc4dcc49a4efba6caa63a4fe083d45ca70a624eeb67bf3a14b442"><div class="ttname"><a href="_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a4fe083d45ca70a624eeb67bf3a14b442">AK_DataNeeded</a></div><div class="ttdeci">@ AK_DataNeeded</div><div class="ttdoc">The consumer needs more.</div><div class="ttdef"><b>Definition:</b> <a href="_common_2_ak_types_8h_source.html#l00239">AkTypes.h:239</a></div></div>
<div class="ttc" id="a_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce_html_a39c6c5d577901802ca77775760b704ce"><div class="ttname"><a href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a></div><div class="ttdeci">uint32_t AkUInt32</div><div class="ttdoc">Unsigned 32-bit integer.</div><div class="ttdef"><b>Definition:</b> <a href="_ak_numeral_types_8h_source.html#l00038">AkNumeralTypes.h:38</a></div></div>
<div class="ttc" id="aclass_ak_audio_buffer_html"><div class="ttname"><a href="class_ak_audio_buffer.html">AkAudioBuffer</a></div><div class="ttdef"><b>Definition:</b> <a href="_ak_common_defs_8h_source.html#l00462">AkCommonDefs.h:463</a></div></div>
<div class="ttc" id="a_win32_2_ak_platform_funcs_8h_aae886a30b939ee13e0abf036fa9e6a15_html_aae886a30b939ee13e0abf036fa9e6a15"><div class="ttname"><a href="_win32_2_ak_platform_funcs_8h_aae886a30b939ee13e0abf036fa9e6a15.html#aae886a30b939ee13e0abf036fa9e6a15">AkAlloca</a></div><div class="ttdeci">#define AkAlloca(_size_)</div><div class="ttdoc">Stack allocations.</div><div class="ttdef"><b>Definition:</b> <a href="_win32_2_ak_platform_funcs_8h_source.html#l00501">AkPlatformFuncs.h:501</a></div></div>
<div class="ttc" id="a_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf_html_ab66f3fb84361798a69b92a110f8a14cf"><div class="ttname"><a href="_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf">AK_RESTRICT</a></div><div class="ttdeci">#define AK_RESTRICT</div><div class="ttdoc">Refers to the __restrict compilation flag available on some platforms.</div><div class="ttdef"><b>Definition:</b> <a href="_platforms_2_windows_2_ak_types_8h_source.html#l00080">AkTypes.h:80</a></div></div>
<div class="ttc" id="aclass_ak_audio_buffer_a537445dce6e3ed09dd2c337fd73c6b41_html_a537445dce6e3ed09dd2c337fd73c6b41"><div class="ttname"><a href="class_ak_audio_buffer_a537445dce6e3ed09dd2c337fd73c6b41.html#a537445dce6e3ed09dd2c337fd73c6b41">AkAudioBuffer::MaxFrames</a></div><div class="ttdeci">AkForceInline AkUInt16 MaxFrames() const</div><div class="ttdef"><b>Definition:</b> <a href="_ak_common_defs_8h_source.html#l00642">AkCommonDefs.h:642</a></div></div>
</body>
</html>
