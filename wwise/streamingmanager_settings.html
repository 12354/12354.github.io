<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Audiokinetic Stream Manager Initialization Settings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Audiokinetic Stream Manager Initialization Settings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table border="1" cellspacing="0" cellpadding="5" bgcolor="#a4ecc9">
<tr>
<td><p class="starttd"><b>Default Streaming Manager Information</b><br  />
<br  />
 This chapter is specific to the default implementation of the high-level Stream Manager's API.</p>
<p class="endtd">The initialization settings of the Stream Manager and the <a class="el" href="namespace_a_k_1_1_stream_mgr_af9d67dd0e502e5603a2921099916e2ab.html#af9d67dd0e502e5603a2921099916e2ab">AK::StreamMgr::Create()</a> method are specific to Audiokinetic's implementation, and are defined in <a class="el" href="_ak_stream_mgr_module_8h.html">AkStreamMgrModule.h</a>. </p>
</td></tr>
</table>
<p>Here is a description of the initialization settings of the default implementation of the Stream Manager. You will certainly have to tweak these settings for your game at some point in order to make best use of I/O and memory resources.</p>
<h1><a class="anchor" id="streamingmanager_settings_defmanagerinit_streammanager"></a>
Stream Manager Settings</h1>
<p>The <a class="el" href="struct_ak_stream_mgr_settings.html">AkStreamMgrSettings</a> structure defines the settings needed for the entire Stream Manager. Default values indicated in each subsection are the values returned by <a class="el" href="namespace_a_k_1_1_stream_mgr_a50fe8111fcb883651390fab6e9dc5ebc.html#a50fe8111fcb883651390fab6e9dc5ebc">AK::StreamMgr::GetDefaultSettings()</a>. These default values may not be adequate for your system. The information contained in <a class="el" href="streamingmanager_tips.html">I/O Tips, Troubleshooting and Optimization</a> may help you choose optimal values.</p>
<h1><a class="anchor" id="streamingmanager_settings_defmanagerinit_device"></a>
Streaming Devices Settings</h1>
<p>The <a class="el" href="struct_ak_device_settings.html">AkDeviceSettings</a> structure defines the settings needed for each device, created with <a class="el" href="namespace_a_k_1_1_stream_mgr_a64a22d377d25137222fbb66ff21965d5.html#a64a22d377d25137222fbb66ff21965d5">AK::CreateDevice()</a>. Default values indicated in each subsection are the values returned by <a class="el" href="namespace_a_k_1_1_stream_mgr_a7d01e09a9bb6b6d34c2bb8f4c8995214.html#a7d01e09a9bb6b6d34c2bb8f4c8995214">AK::StreamMgr::GetDefaultDeviceSettings()</a>. These default values may not be adequate for your system.</p>
<h2><a class="anchor" id="streamingmanager_settings_defmanagerinit_device_uIOMemorySize"></a>
I/O Memory Size</h2>
<p><a class="el" href="struct_ak_device_settings_a75893592924a59881fe2cbca4e4ddd04.html#a75893592924a59881fe2cbca4e4ddd04" title="Size of memory for I/O (for automatic streams). It is passed directly to AK::MemoryMgr::Malign(),...">AkDeviceSettings::uIOMemorySize</a> is the total size of the memory reserved for a device’s automatic streaming. The device creates a special memory pool, to which automatic stream I/O data is written. If you don’t plan to use any automatic streams, specify zero. Note, however, that the sound engine uses automatic streams to play streamed audio files. <a class="el" href="struct_ak_device_settings_a3a99efb65d353954df652c007ac761c5.html#a3a99efb65d353954df652c007ac761c5">AkDeviceSettings::pIOMemory</a>, <a class="el" href="struct_ak_device_settings_ae4d4ef1d88e6a43dd134845f18e26b42.html#ae4d4ef1d88e6a43dd134845f18e26b42" title="I/O memory alignment. It is passed directly to AK::MemoryMgr::Malign().">AkDeviceSettings::uIOMemoryAlignment</a> and <a class="el" href="struct_ak_device_settings_ac765faebf4d47270efbe33cc762192cb.html#ac765faebf4d47270efbe33cc762192cb" title="Attributes for I/O memory. Here, specify the allocation type (AkMemType_Device, and so on)....">AkDeviceSettings::ePoolAttributes</a> are additional parameters that are passed directly to the pool creation method, AK::MemoryMgr::CreatePool().</p>
<p>Defaults:</p><ul>
<li><a class="el" href="struct_ak_device_settings_a3a99efb65d353954df652c007ac761c5.html#a3a99efb65d353954df652c007ac761c5">AkDeviceSettings::pIOMemory</a>: NULL (memory pool is allocated by the device)</li>
<li><a class="el" href="struct_ak_device_settings_a75893592924a59881fe2cbca4e4ddd04.html#a75893592924a59881fe2cbca4e4ddd04" title="Size of memory for I/O (for automatic streams). It is passed directly to AK::MemoryMgr::Malign(),...">AkDeviceSettings::uIOMemorySize</a>: 2 MB</li>
<li><a class="el" href="struct_ak_device_settings_ae4d4ef1d88e6a43dd134845f18e26b42.html#ae4d4ef1d88e6a43dd134845f18e26b42" title="I/O memory alignment. It is passed directly to AK::MemoryMgr::Malign().">AkDeviceSettings::uIOMemoryAlignment</a>: 4 (on Windows - platform specific)</li>
<li><a class="el" href="struct_ak_device_settings_ac765faebf4d47270efbe33cc762192cb.html#ac765faebf4d47270efbe33cc762192cb" title="Attributes for I/O memory. Here, specify the allocation type (AkMemType_Device, and so on)....">AkDeviceSettings::ePoolAttributes</a>: AkMalloc (on Windows - platform specific)</li>
</ul>
<h2><a class="anchor" id="streamingmanager_settings_defmanagerinit_device_uGranularity"></a>
Granularity</h2>
<p>Granularity is specified by <a class="el" href="struct_ak_device_settings_abd4879bfd150b9a2f898102e3815dbe2.html#abd4879bfd150b9a2f898102e3815dbe2" title="I/O requests granularity (typical bytes/request).">AkDeviceSettings::uGranularity</a>. It defines the standard request size sent to the Low-Level I/O, whether it is sent from a standard stream (sliced operation) or an automatic stream (size of a single stream buffer). Automatic streams use a variable number of buffers, depending on the memory available. The total number of buffers available for automatic streaming is equal to<br  />
<a class="el" href="struct_ak_device_settings_a75893592924a59881fe2cbca4e4ddd04.html#a75893592924a59881fe2cbca4e4ddd04" title="Size of memory for I/O (for automatic streams). It is passed directly to AK::MemoryMgr::Malign(),...">AkDeviceSettings::uIOMemorySize</a> / <a class="el" href="struct_ak_device_settings_abd4879bfd150b9a2f898102e3815dbe2.html#abd4879bfd150b9a2f898102e3815dbe2" title="I/O requests granularity (typical bytes/request).">AkDeviceSettings::uGranularity</a>. </p><table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> To avoid starvation because of memory, streams should be at least double-buffered. Therefore, the I/O memory size should be set to at least <div class="fragment"><div class="line">2 * uGranularity * nominal_number_of_streams</div>
</div><!-- fragment --> Note that the actual number of buffers required per stream is dynamic and depends on stream heuristics and the devices target buffer length (see <a class="el" href="struct_ak_device_settings_af396c1626da7df1bbb6d9129e132b02f.html#af396c1626da7df1bbb6d9129e132b02f" title="Targetted automatic stream buffer length (ms). When a stream reaches that buffering,...">AkDeviceSettings::fTargetAutoStmBufferLength</a>). The proper way to determine the I/O memory size that is required for your needs is to compute the sum of the throughput required by all your streams in your worst case scenario and multiply it by fTargetAutoStmBufferLength. In practice, it is easier to start with a large value, profile your game with the Wwise profiler, and use the peak value reported for I/O usage in the Streaming Devices tab. </td></tr>
</table>
<p>Default: 16 KB</p>
<h2><a class="anchor" id="streamingmanager_settings_defmanagerinit_device_threadProperties"></a>
I/O Thread Properties</h2>
<p>All high-level devices use a separate thread to post transfer requests to the Low-Level I/O called "AK::IOThread". You can specify properties for this thread by using <a class="el" href="struct_ak_device_settings_a66496eabd7bf4cd482f2ef9925e489c4.html#a66496eabd7bf4cd482f2ef9925e489c4" title="Scheduler thread properties.">AkDeviceSettings::threadProperties</a>. <a class="el" href="struct_ak_thread_properties.html">AkThreadProperties</a> is defined for each platform in SDK/include/AK/Tools/{Platform name}/AkPlatformFuncs.h. This method typically specifies thread priority and processor.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> The I/O scheduler thread should have a priority above normal because it does not use much of the CPU: it spends most of its time waiting for streams to service, or waiting for the disk controller. However, when it needs to choose a task and post it to the Low-Level I/O, it should be able to do so quickly to maximize the storage device throughput. </td></tr>
</table>
<p>Default: Default platform-specific thread properties (as returned by <a class="el" href="namespace_a_k_p_l_a_t_f_o_r_m_af8ca5269595a1270425d165061ec182a.html#af8ca5269595a1270425d165061ec182a" title="Platform Independent Helper.">AKPLATFORM::AkGetDefaultThreadProperties()</a>), with a priority equal to AK_THREAD_PRIORITY_ABOVE_NORMAL (defined in AkPlatformFuncs.h).</p>
<h2><a class="anchor" id="streamingmanager_settings_defmanagerinit_device_fTargetAutoStmBufferLength"></a>
Target Buffering Length</h2>
<p><a class="el" href="struct_ak_device_settings_af396c1626da7df1bbb6d9129e132b02f.html#af396c1626da7df1bbb6d9129e132b02f" title="Targetted automatic stream buffer length (ms). When a stream reaches that buffering,...">AkDeviceSettings::fTargetAutoStmBufferLength</a> is a heuristic for a device’s I/O scheduler. It applies to automatic streams only. It specifies the ideal buffering time that should be reached, per stream, in milliseconds. The Stream Manager performs I/O for a given stream until that buffering length is met. The time value translates into buffer size using the stream’s throughput heuristic. For example, a 16-bit stereo sound sampled at 44.1 kHz requires a throughput of 172.3 KB/s. If the target buffer length is set to 380 ms, the target buffer size for this stream will be about 64 KB. With more buffering, streams are less likely to starve. On the other hand, the I/O scheduler will be busier and use more CPU, and a larger amount of memory in the streaming I/O pool. The optimal value depends mainly on the low-level storage device bandwidth and the amount of memory available for streaming. Fast devices should use a smaller buffering length, whereas slower devices, or devices whose throughput has a large standard deviation (due to seeking, for example) should use a larger value. When all automatic streams reach their target buffering length, and there is no pending standard streaming operation, the I/O scheduler becomes idle.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> The ideal target buffering length is proportional to the time at which your low-level device transfers data. Try to specify the lowest value possible without having source starvation notifications appear in the Wwise Profiler, under reasonable conditions, with a sufficiently large I/O memory size. Once this is done, you may reduce the I/O memory size to the peak usage value. </td></tr>
</table>
<p>Default: 380 ms.</p>
<h2><a class="anchor" id="streamingmanager_settings_defmanagerinit_device_uMaxConcurrentIO"></a>
Maximum Number of Concurrent I/O Transfers</h2>
<p><a class="el" href="struct_ak_device_settings_af49f8b3af816b58296e952b20de2d7a3.html#af49f8b3af816b58296e952b20de2d7a3" title="Maximum number of transfers that can be sent simultaneously to the Low-Level I/O.">AkDeviceSettings::uMaxConcurrentIO</a> concerns asynchronous low-level devices only. It is the maximum amount of low-level I/O transfers that the streaming device may post concurrently to the low-level I/O at any given time. When the limit is reached, the I/O thread will stop posting requests to the low-level I/O even if there are streams buffered below their target. You may use this value to safely allocate static arrays of structures that you need to track each pending transfer.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><p class="starttd"><b>Tip:</b> If you specify 1, you get the same behavior as with a synchronous device, with asynchronous handshaking instead. This can be useful if your I/O manager only exposes an asynchronous API.</p>
<p class="intertd">You may be tempted to use a large value for this parameter, but there are downsides to this. The streaming device's scheduler posts low-level requests according to the state of each stream at the time it inspects them. If you let it send a lot of requests, and let them remain in the low-level I/O for a long time, the situation is more likely to change in the meantime. For example, streaming sounds may stop, or stop looping. In such cases, these transfers are cancelled and I/O data is flushed upon reception. This may result in a lot of wasted bandwidth.</p>
<p class="endtd">Large amounts of concurrent requests should only be used with devices whose throughput is not linear with the amount of requests. For example, some DMA controllers can be programmed to process many transfers, but the moment when they complete is mostly independent of the amount of transfers that were programmed. </p>
</td></tr>
</table>
<p>Default: 8.</p>
<h2><a class="anchor" id="streamingmanager_settings_defmanagerinit_device_bUseStreamCache"></a>
Use Stream Cache</h2>
<p><a class="el" href="struct_ak_device_settings_aaa0e8dc2b18f827559aaf8672705dd49.html#aaa0e8dc2b18f827559aaf8672705dd49" title="If true, the device attempts to reuse I/O buffers that have already been streamed from disk....">AkDeviceSettings::bUseStreamCache</a> determines whether data caching is enabled or not.</p>
<p>Streaming devices support data caching into their streaming pool. When an I/O operation is executed for a memory block, file metadata is attached to it. If the same stream or another instance of the same stream requires a block of data corresponding to the same file at more or less the same position, this block of data will be used directly, thus avoiding a transfer from the low-level I/O.</p>
<p>You must know that critical data structures are preallocated (from the Stream Manager memory pool) when devices are created. Running out of memory at run-time would result in the I/O thread spinning over nothing with a high priority, having disastrous consequences on the game's performances.</p>
<p>With stream data caching, there may be more than one reference for a given memory block. References to memory blocks are an example of such preallocated critical data structures.</p>
<p>By calling <code><a class="el" href="namespace_a_k_1_1_sound_engine_ae98b64113d2b9bd2e63adef8cee96805.html#ae98b64113d2b9bd2e63adef8cee96805">AK::SoundEngine::PinEventInStreamCache()</a></code>, the user can request that certain events have their media "pinned" into stream cache, so that it is ready and can be played with zero latency when needed. If the data is not already in cache when <code><a class="el" href="namespace_a_k_1_1_sound_engine_ae98b64113d2b9bd2e63adef8cee96805.html#ae98b64113d2b9bd2e63adef8cee96805">AK::SoundEngine::PinEventInStreamCache()</a></code> is called, then the data will be streamed in with a low priority automatic stream. The length, in milliseconds, of each media file that is pinned can be customized using the prefetch slider in the Wwise authoring tool. The data will stay in memory until the user releases the media by calling <code><a class="el" href="namespace_a_k_1_1_sound_engine_a09d2491e7ad56454b3720f182b09549a.html#a09d2491e7ad56454b3720f182b09549a">AK::SoundEngine::UnpinEventInStreamCache()</a></code>.</p>
<p><a class="el" href="struct_ak_device_settings_aaa0e8dc2b18f827559aaf8672705dd49.html#aaa0e8dc2b18f827559aaf8672705dd49" title="If true, the device attempts to reuse I/O buffers that have already been streamed from disk....">AkDeviceSettings::bUseStreamCache</a> specifies if the device should attempt to reuse IO buffers that have already been streamed from disk. This is particularly useful when streaming small looping sounds. The drawback is a small CPU hit when allocating memory, and a slightly larger memory footprint in the StreamManager pool.</p>
<p>Default: false (caching disabled). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
