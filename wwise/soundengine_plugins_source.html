<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Creating Sound Engine Source Plug-ins</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Creating Sound Engine Source Plug-ins </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="se_source_effect"></a>
Source Plug-in Interface Implementation</h1>
<p>Source plug-ins provide audio content to an output buffer using synthesis methods, including physical modeling, modulation synthesis, sampling synthesis, and so on. Writing source plug-ins consists of implementing the <a class="el" href="class_a_k_1_1_i_ak_source_plugin.html" title="Wwise sound engine source plug-in interface (see Creating Sound Engine Source Plug-ins).">AK::IAkSourcePlugin</a> interface as detailed in this document. Only the functions specific to <a class="el" href="class_a_k_1_1_i_ak_source_plugin.html" title="Wwise sound engine source plug-in interface (see Creating Sound Engine Source Plug-ins).">AK::IAkSourcePlugin</a> interface are covered here. Refer to <a class="el" href="soundengine_plugins.html">Creating Sound Engine Plug-ins</a> for information about interface components shared with other plug-in types. Refer to the provided Sine sample plug-in for details (<a class="el" href="samplecode.html">Samples</a>).</p>
<h2><a class="anchor" id="iaksourceeffect_init"></a>
AK::IAkSourcePlugin::Init()</h2>
<p>This method prepares the source plug-in for data processing, allocates memory, and sets up initial conditions.</p>
<p>The plug-in is passed in a pointer to a memory allocator interface (<a class="el" href="class_a_k_1_1_i_ak_plugin_mem_alloc.html">AK::IAkPluginMemAlloc</a>). You should perform all dynamic memory allocation through this interface using the provided memory allocation macros (refer to Allocating/De-allocating Memory in Audio Plug-ins). For the most common memory allocation needs, namely allocation at initialization and release at termination, the plug-in does not need to retain a pointer to the allocator. It will also be provided to the plug-in on termination.</p>
<p>The <a class="el" href="class_a_k_1_1_i_ak_source_plugin_context.html">AK::IAkSourcePluginContext</a> interface allows to retrieve information such as the number of loop iterations or other information related to the context in which the source plug-in is operated. It may also access the global context through AK::IAkPluginContextBase::GlobalContext().</p>
<p>The plug-in also receives a pointer to its associated parameter node interface (<a class="el" href="class_a_k_1_1_i_ak_plugin_param.html">AK::IAkPluginParam</a>). Most plug-ins will want to keep a reference to the associated parameter node to be able to retrieve parameters at runtime. Refer to Communication Between Parameter Nodes and Plug-ins. for more details.</p>
<p>All of these interfaces will remain valid throughout the plug-in's lifespan so it is safe to keep an internal reference to them when necessary.</p>
<p>The audio format native to the platform on which the plug-in is executed is passed as an argument of the <code>AK::IAkSourcePlugin::Init()</code> function. It is highly recommended that plug-ins are output in the platform's native format to avoid any performance penalty incurred by audio format conversion. If for some reason the source is not suited to be output in this format, interleaved 16-bit signed samples may also be output. In multi-channel configurations, the source plug-in must also specify whether it is going to output interleaved or deinterleaved data (<code>AkAudioFormat::uInterleaveID</code>). The default, native setting is AK_NONINTERLEAVED. When outputting deinterleaved data, a source plug-in should use the <code>AkAudioBuffer::GetChannel()</code> method to access buffers of each channel. When outputting interleaved data, it should use <code>AkAudioBuffer::GetInterleavedData()</code>. In the case of 7.1 for interleaved data of source plug-ins, the channel ordering is L-R-C-LFE-BL-BR-SL-SR. Refer to Accessing Data Using AkAudioBuffer Structure for more details.</p>
<p>The channel mask passed in will default to a mono (center speaker only) channel configuration. You may change this channel mask to whatever channel configuration you want your source plug-in to output. In the code example below, the channel mask was changed to stereo. The audio buffers to be received at each Execute will be able to accommodate the format specified by the plug-in upon initialization and will not change for the lifespan of the plug-in making it safe to store any format information required for later processing in the initialization routine.</p>
<div class="fragment"><div class="line">AKRESULT CAkDCOffset::Init( <a class="code" href="class_a_k_1_1_i_ak_plugin_mem_alloc.html">AK::IAkPluginMemAlloc</a> *     in_pAllocator,              <span class="comment">// Memory allocator interface.</span></div>
<div class="line">                            <a class="code" href="class_a_k_1_1_i_ak_source_plugin_context.html">AK::IAkSourcePluginContext</a> * in_pSourcePluginContext,   <span class="comment">// Source plugin context</span></div>
<div class="line">                            <a class="code" href="class_a_k_1_1_i_ak_plugin_param.html">AK::IAkPluginParam</a> *        in_pParams,                 <span class="comment">// Effect parameters.</span></div>
<div class="line">                            <a class="code" href="struct_ak_audio_format.html">AkAudioFormat</a> &amp;             io_rFormat                  <span class="comment">// Supported audio output format.</span></div>
<div class="line">                            )   </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Keep a pointer to associated parameter node.</span></div>
<div class="line">    m_pParams = <span class="keyword">reinterpret_cast&lt;</span>CAkMyPluginParams*<span class="keyword">&gt;</span>( in_pParams );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Setup helper to handle looping and possibly changing duration of synthesis</span></div>
<div class="line">    m_DurationHandler.Setup( m_pParams-&gt;fDuration, in_pSourceFXContext-&gt;GetNumLoops(), io_rFormat.uSampleRate ); </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Output format set to Mono native by default (input). Change to Stereo output.</span></div>
<div class="line">    io_rFormat.channelConfig.SetStandard(AK_SPEAKER_SETUP_STEREO);</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> AK_Success;</div>
<div class="line">}</div>
</div><!-- fragment --><table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> AK::IAkSourcePlugin::Init() is called every time the effect is instantiated, which happens when a voice starts playing or a mixing bus is instantiated. Since other sounds will typically be already playing, this needs to occur within a reasonable amount of time. If you need to initialize large common/global data structures, then maybe you should do so when registering the plugin library. See Using Global Sound Engine Callbacks From Plug-ins for more details. </td></tr>
</table>
<h2><a class="anchor" id="iaksourceeffect_getduration"></a>
AK::IAkSourcePlugin::GetDuration()</h2>
<p>This method is called by the sound engine after initialization time to determine the approximate duration of the source for the purpose of processing crossfades during sound transitions. The estimated duration of the source should be returned in milliseconds. If looping is applied with a finite number of iterations, the returned duration should correspond to the total duration, considering how many sound iterations will be played. When infinite looping is selected or when the duration of the source is unknown the returned duration should be zero. Note that the number of loop iterations retrieved through AK::IAkSourcePluginContext::GetNumLoops() when infinite looping is selected is always zero.</p>
<div class="fragment"><div class="line"><span class="comment">// Get the duration of the source in milliseconds.</span></div>
<div class="line">AkTimeMs CAkDCOffset::GetDuration( )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_DurationHandler.GetDuration() * 1000.f; </div>
<div class="line">}</div>
</div><!-- fragment --><table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> If RTPC parameters change the duration of the plug-in, the crossfade transition may not last the expected duration. </td></tr>
</table>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> The easiest way to handle most time elapsed management (including looping) for a source plug-in is to use the <a class="el" href="class_ak_f_x_duration_handler.html">AkFXDurationHandler</a> service as shown in the Sine plug-in example (<a class="el" href="samplecode.html">Samples</a>). </td></tr>
</table>
<h2><a class="anchor" id="iaksourceeffect_stoplooping"></a>
AK::IAkSourcePlugin::StopLooping()</h2>
<p>This method is called by the sound engine when a break action is received. A break action is a smooth stop. The plug-in may implement a way to smoothly terminate playing in this function. Usually it should simply stop looping and play the release if there is one. The function must return AK_Success if it ignores the break command or if it handles it. If the plug-in does not handle it, then this function should return AK_Fail, which will cause the source to stop playing.</p>
<p>Stop playback after the current loop iteration AKRESULT CAkDCOffset::StopLooping() { m_DurationHandler.SetLooping( 1 ); // No longer looping. return AK_Success; }</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> This function is optional. If you don't implement it, the source will ignore break commands and play normally until the end. </td></tr>
</table>
<h2><a class="anchor" id="iaksourceeffect_getenvelope"></a>
AK::IAkSourcePlugin::GetEnvelope()</h2>
<p>This method is called to get an estimate of the normalized amplitude envelope value, between 0 and 1, that a source plugin will generate at the next call to Execute(). In the current version of Wwise, it is used for HDR processing, where the algorithm uses estimates of the envelope to attenuate softer sounds accordingly. This feature is optional: if you return 1 (default), the attenuation of softer sounds will be constant when your plugin is used under an HDR bus.</p>
<p>If you decide to implement it, ensure that it returns the normalized envelope value, that is, that you know the value of the peak of the waveform that you are about to generate, or that amplitude envelope and gain are decoupled so that you may return only the current value of the envelope.</p>
<h2><a class="anchor" id="iaksourceeffect_execute"></a>
AK::IAkSourcePlugin::Execute()</h2>
<p>This method executes the source plug-in's audio signal processing algorithm and fills given audio output buffers (refer to Accessing Data Using AkAudioBuffer Structure). Upon function entrance, the AkAudioBuffer::uValidFrames field of the output buffer will always be zero, meaning that there are no valid audio frames in the channel buffers. The AkAudioBuffer::MaxFrames() method returns the maximum number of audio sample frames that the source should fill. The plug-in determines how many output sample frames need to be produced, which may depend on parameter values such as duration. After DSP execution, the source plug-in must tell the audio pipeline how many sample frames were effectively produced by setting the AkAudioBuffer::uValidFrames field of the audio buffer accordingly.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> In general, the algorithm should always attempt to produce full buffers to avoid pipeline starvation. </td></tr>
</table>
<p>The Execute() routine will be called as long as the source plug-in sets the eState field of the <a class="el" href="class_ak_audio_buffer.html">AkAudioBuffer</a> structure to AK_DataReady. When AK_NoMoreData is returned, the plug-in will be terminated and will no longer be called by the audio pipeline. The current version of Wwise supports source plug-ins that output up to 6 channels (5.1 setup, see Channel Ordering).</p>
<h2><a class="anchor" id="iaksourceeffect_execnotes"></a>
Important Notes for Source Plugin Execution</h2>
<ul>
<li>Source plug-ins must always generate complete sample frames, that is, samples for each channel of the specified output format.</li>
<li>It is your responsibility to ensure that your plug-in checks parameters with RTPC support at runtime. You should implement accessor methods in the shared parameter interface for retrieving values from the parameter node and invoke them as often as required at runtime. For more information, refer to Communication Between Parameter Nodes and Plug-ins.. For most parameter values, checking once every buffer is sufficient. Look at the sample code examples to see how parameter values (for example, gains) can be ramped to avoid signal discontinuities (<a class="el" href="samplecode.html">Samples</a>).</li>
<li>When a plug-in is used in Wwise, parameter changes are sent down to the parameter node whether or not the parameter supports RTPCs. This allows the plugin to support runtime value changes on non-RTPC values if desired for Wwise usage. If you do not want your plugin to support this, you should make a copy of the parameter values at initialization time to ensure they remain the same throughout the plug-in's duration. Refer to CAkToneGen::Init for an example of this.</li>
<li>You should optimize processing performed in the AK::IAkSourcePlugin::Execute() method so it can be completed well within the time slice represented by a buffer. Failure to do so may result in source starvation for this and possibly other source pipelines. It can also have a significant impact on the sound engine's performance.</li>
</ul>
<p>A DC offset plug-in Execute() function is provided below. Refer to CAkSrcSine::Execute() and the various tone generator DSP routines for more details.</p>
<div class="fragment"><div class="line"><span class="comment">// This example demonstrates a simple application which outputs a steady DC offset signal using an RTPC parameter.</span></div>
<div class="line"><span class="keywordtype">void</span> CAkDCOffset::Execute( <a class="code" href="class_ak_audio_buffer.html">AkAudioBuffer</a> * io_pBuffer ) </div>
<div class="line">{   </div>
<div class="line">    <span class="comment">// Set new duration when it changes (e.g. RTPC parameter)</span></div>
<div class="line">    m_DurationHandler.SetDuration( m_pParams-&gt;fDuration );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Determine how many sample frames to produce this execution and set uValidFrames and eState according to current state</span></div>
<div class="line">    m_DurationHandler.ProduceBuffer( io_pBuffer ); </div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Retrieve RTPC DC offset parameter</span></div>
<div class="line">    AkReal32 fDCOffset = m_pParams-&gt;GetDCOffset( );</div>
<div class="line">        </div>
<div class="line">    <span class="comment">// DC offset output DSP (supports any number of channels)</span></div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uNumChannels; ++i )</div>
<div class="line">    {</div>
<div class="line">        AkSampleType * pBufOut = io_pBuffer-&gt;GetChannel(i); <span class="comment">// AkSampleType is platform specific (AkReal32 on software platforms).</span></div>
<div class="line">        AkUInt32 uFrameCount = io_pBuffer-&gt;uValidFrames;</div>
<div class="line">        <span class="keywordflow">while</span> ( uFrameCount-- )</div>
<div class="line">        {</div>
<div class="line">             *pBufOut++ = AK_FLOAT_TO_SAMPLETYPE( fDCOffset );      <span class="comment">// DC-offset output, will convert normalized float to platform supported format.</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="iaksourceeffect_timeskip"></a>
AK::IAkSourcePlugin::TimeSkip()</h2>
<p>AK::IAkSourcePlugin::TimeSkip() replaces Execute() when a virtual voice is set to "Play from elapsed time". This allows the source plug-ins to keep updating their internal state (such as advanced synthesis time) if desired. It can be used to simulate processing that would have taken place, while avoiding most of the CPU hit of plug-in execution. Given the number of frames requested, adjust the number of frames that would have been produced by a call to Execute() in the io_uFrames parameter and return AK_DataReady or AK_NoMoreData, depending on whether or not there would be audio output at that point.</p>
<p>Returning AK_NotImplemented will trigger a normal execution of the voice (as if it were not virtual). Therefore, it does not enable the CPU savings of a proper "Play from elapsed time" behavior.</p>
<div class="fragment"><div class="line"><span class="comment">// This example shows how to skip the processing of some frames when the virtual voice is set to &quot;Play from elapsed time&quot;.</span></div>
<div class="line">AKRESULT CAkDCOffset::TimeSkip( AkUInt32 &amp;io_uFrames )</div>
<div class="line">{</div>
<div class="line">    AkUInt16 uValidFrames = (AkUInt16)io_uFrames;</div>
<div class="line">    AkUInt16 uMaxFrames = (AkUInt16)io_uFrames;</div>
<div class="line">    AKRESULT eResult = m_DurationHandler.ProduceBuffer( uMaxFrames, uValidFrames );</div>
<div class="line">    io_uFrames = uValidFrames;</div>
<div class="line">    <span class="keywordflow">return</span> eResult;</div>
<div class="line">}</div>
<div class="line">\</div>
</div><!-- fragment --><p>For more information, refer to the following sections: Sound Engine Plug-ins Overview, Implementing an Effect Plug-in Interface, <a class="el" href="effectpluginwwise.html">Writing the Authoring Part of an Audio Plug-in</a> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclass_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c_html_ad2bc3b8ddd61eaa0c111798d5f9e8c9c"><div class="ttname">AkAudioBuffer::GetChannel</div><div class="ttdeci">AkSampleType * GetChannel(AkUInt32 in_uIndex)</div><div class="ttdef"><b>Definition:</b> AkCommonDefs.h:574</div></div>
<div class="ttc" id="a_ak_numeral_types_8h_a7100a9b0a3b01df7639c1dc512678219_html_a7100a9b0a3b01df7639c1dc512678219"><div class="ttname">AkUInt16</div><div class="ttdeci">uint16_t AkUInt16</div><div class="ttdoc">Unsigned 16-bit integer.</div><div class="ttdef"><b>Definition:</b> AkNumeralTypes.h:37</div></div>
<div class="ttc" id="a_common_2_ak_types_8h_a8a4d0aa5dba6f9922d6b7b3e48958b24_html_a8a4d0aa5dba6f9922d6b7b3e48958b24"><div class="ttname">AkTimeMs</div><div class="ttdeci">AkInt32 AkTimeMs</div><div class="ttdoc">Time in ms.</div><div class="ttdef"><b>Definition:</b> AkTypes.h:138</div></div>
<div class="ttc" id="aclass_a_k_1_1_i_ak_plugin_param_html"><div class="ttname"><a href="class_a_k_1_1_i_ak_plugin_param.html">AK::IAkPluginParam</a></div><div class="ttdef"><b>Definition:</b> IAkPlugin.h:620</div></div>
<div class="ttc" id="a_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63_html_a64f7d1f79613cc4dcc49a4efba6caa63"><div class="ttname">AKRESULT</div><div class="ttdeci">AKRESULT</div><div class="ttdoc">Standard function call result.</div><div class="ttdef"><b>Definition:</b> AkTypes.h:213</div></div>
<div class="ttc" id="astruct_ak_audio_format_a73de76fa89ed81baa5265448bd6deefe_html_a73de76fa89ed81baa5265448bd6deefe"><div class="ttname">AkAudioFormat::channelConfig</div><div class="ttdeci">AkChannelConfig channelConfig</div><div class="ttdoc">Channel configuration.</div><div class="ttdef"><b>Definition:</b> AkCommonDefs.h:65</div></div>
<div class="ttc" id="anamespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8_html_a596691b552b507c26b4df958ee1c6de8"><div class="ttname">AK::Comm::Init</div><div class="ttdeci">AKSOUNDENGINE_API AKRESULT Init(const AkCommSettings &amp;in_settings)</div></div>
<div class="ttc" id="a_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98_html_afc38459f26e2b23defe588026e886a98"><div class="ttname">AkReal32</div><div class="ttdeci">float AkReal32</div><div class="ttdoc">32-bit floating point</div><div class="ttdef"><b>Definition:</b> AkNumeralTypes.h:46</div></div>
<div class="ttc" id="a_common_2_ak_types_8h_a64f7d1f79613cc4dcc49a4efba6caa63_html_a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e"><div class="ttname">AK_Success</div><div class="ttdeci">@ AK_Success</div><div class="ttdoc">The operation was successful.</div><div class="ttdef"><b>Definition:</b> AkTypes.h:215</div></div>
<div class="ttc" id="aclass_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd_html_ab7f90fd99119b56e92e4cbf3559f98cd"><div class="ttname">AkAudioBuffer::uValidFrames</div><div class="ttdeci">AkUInt16 uValidFrames</div><div class="ttdoc">Number of valid sample frames in the audio buffer.</div><div class="ttdef"><b>Definition:</b> AkCommonDefs.h:655</div></div>
<div class="ttc" id="aclass_a_k_1_1_i_ak_plugin_mem_alloc_html"><div class="ttname"><a href="class_a_k_1_1_i_ak_plugin_mem_alloc.html">AK::IAkPluginMemAlloc</a></div><div class="ttdef"><b>Definition:</b> IAkPluginMemAlloc.h:43</div></div>
<div class="ttc" id="aclass_a_k_1_1_i_ak_source_plugin_context_html"><div class="ttname"><a href="class_a_k_1_1_i_ak_source_plugin_context.html">AK::IAkSourcePluginContext</a></div><div class="ttdef"><b>Definition:</b> IAkPlugin.h:416</div></div>
<div class="ttc" id="a_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb_html_a58f11a728038d16fe4187612a7a842fb"><div class="ttname">AkSampleType</div><div class="ttdeci">AkReal32 AkSampleType</div><div class="ttdoc">Audio sample data type (32 bit floating point)</div><div class="ttdef"><b>Definition:</b> AkCommonDefs.h:456</div></div>
<div class="ttc" id="astruct_ak_channel_config_a4c0f4b3d39608a10c9b330c1ef8281a7_html_a4c0f4b3d39608a10c9b330c1ef8281a7"><div class="ttname">AkChannelConfig::SetStandard</div><div class="ttdeci">AkForceInline void SetStandard(AkUInt32 in_uChannelMask)</div><div class="ttdoc">Set channel config as a standard configuration specified with given channel mask.</div><div class="ttdef"><b>Definition:</b> AkSpeakerConfig.h:563</div></div>
<div class="ttc" id="a_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce_html_a39c6c5d577901802ca77775760b704ce"><div class="ttname">AkUInt32</div><div class="ttdeci">uint32_t AkUInt32</div><div class="ttdoc">Unsigned 32-bit integer.</div><div class="ttdef"><b>Definition:</b> AkNumeralTypes.h:38</div></div>
<div class="ttc" id="aclass_ak_audio_buffer_html"><div class="ttname"><a href="class_ak_audio_buffer.html">AkAudioBuffer</a></div><div class="ttdef"><b>Definition:</b> AkCommonDefs.h:463</div></div>
<div class="ttc" id="a_ak_speaker_config_8h_a472757ac65daebc42373c503d4c3c894_html_a472757ac65daebc42373c503d4c3c894"><div class="ttname">AK_SPEAKER_SETUP_STEREO</div><div class="ttdeci">#define AK_SPEAKER_SETUP_STEREO</div><div class="ttdoc">2.0 setup channel mask</div><div class="ttdef"><b>Definition:</b> AkSpeakerConfig.h:60</div></div>
<div class="ttc" id="astruct_ak_audio_format_html"><div class="ttname"><a href="struct_ak_audio_format.html">AkAudioFormat</a></div><div class="ttdoc">Defines the parameters of an audio buffer format.</div><div class="ttdef"><b>Definition:</b> AkCommonDefs.h:62</div></div>
<div class="ttc" id="a_i_ak_plugin_8h_a441dc3050f2787f07e0678ab0d258002_html_a441dc3050f2787f07e0678ab0d258002"><div class="ttname">AK_FLOAT_TO_SAMPLETYPE</div><div class="ttdeci">#define AK_FLOAT_TO_SAMPLETYPE(__in__)</div><div class="ttdoc">This function can be useful to convert from normalized floating point audio samples to HW-pipeline fo...</div><div class="ttdef"><b>Definition:</b> IAkPlugin.h:1167</div></div>
<div class="ttc" id="astruct_ak_audio_format_ad94d7b21266cb1d8a9aa5557f875d0fa_html_ad94d7b21266cb1d8a9aa5557f875d0fa"><div class="ttname">AkAudioFormat::uSampleRate</div><div class="ttdeci">AkUInt32 uSampleRate</div><div class="ttdoc">Number of samples per second.</div><div class="ttdef"><b>Definition:</b> AkCommonDefs.h:63</div></div>
</body>
</html>

