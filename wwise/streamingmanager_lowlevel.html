<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Low-Level I/O</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Low-Level I/O </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table border="1" cellspacing="0" cellpadding="5" bgcolor="#a4ecc9">
<tr>
<td><b>Default Streaming Manager Information</b><br  />
<br  />
 The Low-Level I/O is a submodule of the default implementation of the high-level Stream Manager's API, which serves to provide an interface for I/O transfers that you will find much simpler to implement than the high-level Stream Manager API. It is therefore only relevant in the context of the default implementation of the Stream Manager. </td></tr>
</table>
<h1><a class="anchor" id="streamingmanager_lowlevel_intro"></a>
Introduction</h1>
<p>The Low-Level I/O system is specific to Audiokinetic's implementation of the Stream Manager. Its interfaces are defined in <em>&lt;Wwise Installation&gt;/SDK/include/AK/SoundEngine/AkStreamMgrModule.h</em>.</p>
<p>The Low-Level I/O system has two purposes:</p><ul>
<li>Resolving file location.</li>
<li>Abstracting actual I/O transfers.</li>
</ul>
<p>One and only one object that implements <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_file_location_resolver.html">AK::StreamMgr::IAkFileLocationResolver</a>, referred to as the File Location Resolver, must be registered to the Stream Manager (using <code>AK::StreamMgr::SetFileLocationResolver()</code>). To open a standard or automatic stream, the Stream Manager will call <code>AK::StreamMgr::IAkFileLocationResolver::GetNextPreferredDevice()</code> to find which streaming device is likely to have the file. Streaming devices are created and registered in the Stream Manager using <code>AK::StreamMgr::CreateDevice()</code>.</p>
<p>For each streaming device, a low-level I/O hook must be provided. This I/O hook implements <code><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook.html">AK::StreamMgr::IAkLowLevelIOHook</a></code> and is responsible for communicating with the platform's I/O API and handles the unique properties and behavior of that physical device. Whenever a streaming device needs to perform an I/O transfer, it calls the low-level I/O hook's <code>AK::StreamMgr::IAkLowLevelIOHook::BatchRead()</code>, or <code>AK::StreamMgr::IAkLowLevelIOHook::BatchWrite()</code> method. No direct call to a platform's I/O API is ever issued from the High-Level Stream Manager. Together, the File Location Resolver and I/O hooks constitute the Low-Level I/O system.</p>
<p>The following figure illustrates the Low-Level I/O system interfaces and how they are viewed by the default Stream Manager.</p>
<div class="image">
<img src="LowLevelIO.gif" alt=""/>
</div>
<p>Game titles need to implement Low-Level I/O interfaces to resolve file location and perform actual I/O transfers. The easiest and most efficient way to integrate the Wwise sound engine's I/O management in your game is to use the default implementation of the Stream Manager and implement a Low-Level I/O system. From there, you can perform native file reads, or you can route the I/O requests to your own I/O management technology.</p>
<p>Wwise's SDK includes default implementations for the Low-Level I/O. It can be used as is, or as a starting point to implement your own. Refer to the Sample Default Implementation Walkthrough section for a detailed overview of the Low-Level I/O samples.</p>
<h1><a class="anchor" id="streamingmanager_lowlevel_location"></a>
File Location Resolving</h1>
<h2><a class="anchor" id="streamingmanager_lowlevel_location_filelocationresolver"></a>
File Location Resolver</h2>
<p>A File Location Resolver needs to be registered to the Stream Manager using <code>AK::StreamMgr::SetFileLocationResolver()</code>. Whenever the Stream Manager creates a stream object, it calls this resolver's GetNextPreferredDevice() method and it should return the AkDeviceID that identifies the I/O Device to use to open the file. The purpose of this function is to find the file location only from its name, flags, language, etc. without performing a disk operation or other physical check. The real Open call will be forwarded to the specified device to perform the disk operation. Therefore, this function is expected to return quickly. If the Device fails to find or open the file, GetNextPreferredDevice will be called again. If no other Devices are known, or the file is unlikely to be found in other locations, then AK_FileNotFound should be returned to notify the end of the search.</p>
<p>The same number of files exist simultaneously in the Low-Level I/O as stream objects in the Stream Manager.</p>
<p>The game must create at least one streaming device in the Stream Manager using <code>AK::StreamMgr::CreateDevice()</code>. The returned AkDeviceID should be kept by the caller and returned in <code>AK::StreamMgr::GetNextPreferredDevice</code> as described above. It may however create as many devices as required. Each streaming device runs in its own thread, and sends I/O requests to its own I/O hook. Typically, you should create one streaming device per physical device. In the <a class="el" href="struct_ak_file_desc.html">AkFileDesc</a> structure, there is a field called deviceID. The File Location Resolver needs to set it to the deviceID of one of the streaming devices that were created. This is how file handling is dispatched to the appropriate device. Additionally, the file's size and offset (<code>uSector</code>) must be returned, and a system file handle should be created (although this is not strictly necessary).</p>
<h2><a class="anchor" id="streamingmanager_lowlevel_location_filedesc"></a>
File Description</h2>
<p>Clients of the Stream Manager identify files either using strings (const AkOSChar *), IDs (AkFileID, integer), or file descriptors (<a class="el" href="struct_ak_file_desc.html">AkFileDesc</a>). This is why the stream creation methods of the Stream Manager (<code>AK::IAkStreamMgr::CreateStd()</code>, <code>AK::IAkStreamMgr::CreateAuto()</code>) use a struct call <a class="el" href="struct_ak_file_open_data.html">AkFileOpenData</a> that groups both possible file identification methods. The <code>AK::StreamMgr::IAkLowLevelIOHook::Open()</code> method must create a valid file descriptor, once the file is opened.</p>
<p>This file descriptor is passed back in every call to methods of the low-level I/O hooks. Three members of the structure are used by the High-Level Stream Manager:</p>
<ul>
<li>deviceID: Needs to be a valid device ID acquired from a call to <code>AK::CreateDevice()</code>. It is used by the Stream Manager to associate the file to the proper high-level device. Once the association is made, I/O transfers are executed through the I/O hook that was passed when creating the device.</li>
<li>uSector: The offset of the beginning of the described file. This is relative to the beginning of the file represented by the AkFileHandle <code>AkFileDesc::hFile</code>. It is expressed in terms of blocks (sectors), which size corresponds to the value returned by <code>AK::StreamMgr::IAkLowLevelIOHook::GetBlockSize()</code> for this file descriptor. When the streaming device calls a method for I/O transfer, it sends the offset (in bytes) from the beginning of the file to its low-level I/O hook as part of the AkTransferInfo structure. The offset is computed this way: Current_Position + ( AkFileDesc::uSector * Block_Size). Note that the block size is also queried through this hook, once for each file descriptor.</li>
<li>iFileSize: Used by the Stream Manager to detect the end of file. It can then report it back to users (through <code>AK::IAkStdStream::GetPosition()</code>, <code>AK::IAkAutoStream::GetPosition()</code>) and stop automatic streams' I/O transfers.</li>
</ul>
<p>The remaining members are owned exclusively by the Low-Level I/O system. For example, <code>AkFileHandle</code>, which is typedefined to HANDLE in Win32, can be used to hold an actual valid file handle that is passed to Win32's <code>ReadFile()</code>. However, it can also be used as an ID, or a pointer. High-level devices never modify or read file descriptor fields. Thus, the Low-Level I/O is free to close and reopen a file handle, for example, if files have been laid out redundantly on the game disk.</p>
<p>The file descriptor structure that is returned by <code>AK::StreamMgr::IAkLowLevelIOHook::Open()</code> needs to remains the same throughout the lifetime of its associated stream object, until <code>AK::StreamMgr::IAkLowLevelIOHook::Close()</code> is called.</p>
<h2><a class="anchor" id="streamingmanager_lowlevel_location_deferred_open"></a>
Deferred Opening</h2>
<p>All file open operations carried out by <code>AK::StreamMgr::IAkLowLevelIOHook::Open()</code> can be synchronous or deferred. If the native API of the device supports deferred opening, it is always better to use it for performance reasons. This way the file open and read/write operations might be carried out in parallel, or prioritized differently, on certain systems.</p>
<p>The parameter to Open() is an <a class="el" href="struct_ak_async_file_open_data.html">AkAsyncFileOpenData</a> struct which derives from <a class="el" href="struct_ak_file_open_data.html">AkFileOpenData</a> that contains all the information passed from the <code>AK::IAkStreamMgr::CreateStd()</code> or <code>AK::IAkStreamMgr::CreateAuto()</code> functions. It also contains a callback function necessary to notify the completion of the Open operation to the high-level Streaming Manager and the return <code><a class="el" href="struct_ak_file_desc.html">AkFileDesc</a></code> structure to fill out.</p>
<p>There are two modes of operation to consider when implementing <code>AK::StreamMgr::IAkLowLevelIOHook::Open()</code>: asynchronous and synchronous.</p>
<p>If the operation is asynchronous, set up what is necessary to dispatch the Open operation and then return AK_Deferred. This signals that the result of the operation will come through the notification callback (io_pOpenData-&gt;pCallback). It is imperative to notify of the result once it is known, otherwise the stream object waiting for this file will stay alive indefinitely, using up memory and probably cause a memory leak. If the result reported by io_pOpenData-&gt;pCallback is AK_Success, it is expected that (io_pOpenData-&gt;pFileDesc) is filled properly and usable.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> The <a class="el" href="struct_ak_async_file_open_data.html">AkAsyncFileOpenData</a> (io_pOpenData) parameter that is passed to <code>AK::StreamMgr::IAkLowLevelIOHook::Open()</code> will stay valid until the notification (io_pOpenData-&gt;pCallback) is received. </td></tr>
</table>
<p>If the file is opened immediately (synchronously), Open() must return AK_Success and the file descriptor (io_pOpenData-&gt;pFileDesc) filled properly. Return AK_FileNotFound if the file was not found. Other error codes are possible, such as AK_FilePermissionError, AK_FilePathTooLong or AK_UnknownFileError. In the synchronous operation you should not call the notification callback (io_pOpenData-&gt;pCallback), regardless of the success or not of the operation.</p>
<h2><a class="anchor" id="streamingmanager_lowlevel_location_fsflags"></a>
File System Flags</h2>
<p>The Stream Manager's <code>AK::IAkStreamMgr::CreateStd()</code> and <code>AK::IAkStreamMgr::CreateAuto()</code> methods accept a pointer to an <a class="el" href="struct_ak_file_system_flags.html" title="File system flags for file descriptors mapping.">AkFileSystemFlags</a> structure, which is passed to <code>AK::StreamMgr::IAkFileLocationResolver::GetNextPreferredDevice()</code> and <code>AK::StreamMgr::IAkLowLevelIOHook::Open()</code>. This structure is a way to pass information directly from the users to the Low-Level I/O. This information is used to complete the file location logic, for example. Generic users of the Stream Manager can pass NULL, but the sound engine always passes a structure filled with relevant information, so that the File Location Resolver knows that a request comes from the sound engine.</p>
<p>The file system flag structure contains the following fields:</p><ul>
<li>uCompanyID: the sound engine always sets this field to AKCOMPANYID_AUDIOKINETIC, so the implementer of the Low-Level I/O knows that this file must be read by the sound engine. The sound engine passes AKCOMPANYID_AUDIOKINETIC_EXTERNAL in the case of streamed external sources.</li>
<li>uCodecID: this field can be used to distinguish between file types. It is needed for file types used by the sound engine. The codec IDs used by the sound engine are defined in AkTypes.h. The host program may also define its own IDs with the same values, as long as it does not set the companyID to AKCOMPANYID_AUDIOKINETIC or AKCOMPANYID_AUDIOKINETIC_EXTERNAL. Note the predefined CodecID AKCODECID_BANK, AKCODECID_BANK_EVENT, AKCODECID_BANK_BUS which, on top of the traditional Codecs, can be useful for file organization.</li>
<li>bIsLanguageSpecific: this field indicates whether the file being looked up is specific to the current language. Typically, a file that has language-specific content exists in different locations (language folders typically). The Low-Level I/O needs to resolve the path according to the language currently selected. See Language-Specific ("Voice" and "Mixed") Soundbanks for more details.</li>
<li>Custom parameter and size: Used for game-specific extensions of the file location scheme. For example, extensions can be copied in the file descriptor. The sound engine always passes 0.</li>
</ul>
<h2><a class="anchor" id="streamingmanager_lowlevel_location_resolution"></a>
Resolution of the Sound Engine Files</h2>
<p>The sound engine reads SoundBank files and streamed audio files. This subsection explains how the Low-Level I/O can resolve their identifiers to actual files.</p>
<p>Different strategies exist to map the ID received in AK::StreamMgr::IAkLowLevelIOHook::Open() to a valid file descriptor in the Low-Level I/O:</p><ul>
<li>implement and use a map of IDs to file names</li>
<li>create file name strings out of IDs</li>
<li>get the system handle of a big file that concatenates all streamed audio files (for e.g. a file package generated with the File Packager application - refer to the Wwise Help for more details), and implement and use a map of IDs to file descriptor structures that define their size and offset in this big file.</li>
</ul>
<p>The SDK samples of the Low-Level I/O resolve file location using two different strategies. One of them (<b>CAkFileLocationBase</b>) concatenates paths, set globally, to create a full path string that can be used with platform <code>fopen()</code> methods. The other one (<code><b>CAkFilePackageLowLevelIO</b></code>) manages a file package that was created with the File Packager utility. A file package is simply a big file in which many files are concatenated, with a header that indicates the relative offset of each original file.</p>
<p>Implementations of File Location Resolvers are provided as SDK samples. They use a different strategy to manage file location. These strategies are described in the sample code walkthroughs, at the end of this section.</p>
<p>Refer to Basic File Location for a description of the strategy used by the default implementations of the Low-Level I/O.</p>
<p>Refer to File Location for a description of the strategy used by implementations of the Low-Level I/O that use File Packages (<b>CAkFilePackageLowLevelIO</b>).</p>
<h3><a class="anchor" id="streamingmanager_lowlevel_location_soundbanks"></a>
SoundBanks</h3>
<p>Following an explicit or implicit request to load a bank from the main API (<code>AK::SoundEngine::LoadBank()</code> and <code>AK::SoundEngine::PrepareEvent()</code>), the Bank Manager of the sound engine may call either the ANSI string or the ID overload of AK::IAkStreamMgr::CreateStd(). For a detailed explanation on the conditions that determine which overload is chosen, refer to Loading Banks From File System.</p>
<p>In both cases, AKCOMPANYID_AUDIOKINETIC is used as the company ID in the file system flags, and AKCODECID_BANK is used as the codec ID.</p>
<p>The <code>LoadBank()</code> methods of the sound engine API do not expose a flag to specify whether or not the bank is language-specific. It is up to your implementation of the Low-Level I/O to resolve this. Since the sound engine is not aware of the SoundBank's language specificity, it calls the Stream Manager with the bIsLanguageSpecific flag set as True. If the Stream Manager (Low-Level I/O) fails to open it, the sound engine tries again, this time with the <code>bIsLanguageSpecific</code> flag set as <code>False</code>.</p>
<p>Refer to Language-Specific ("Voice" and "Mixed") Soundbanks for more information on working with language-specific banks in the Wwise SDK.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> If you want to avoid having the Bank Manager call the Stream Manager twice for unlocalized banks and your file organization scheme allows you to find it regardless of language, you may ignore the bIsLanguageSpecific flag and open the soundbank directly, at the correct location. Only you know what and where the soundbanks are. Also, the cookie that you pass to asynchronous versions of AK::SoundEngine::LoadBank() is passed to the AK::StreamMgr::IAkLowLevelIOHook::Open() as the value of in_pFlags-&gt;pCustomData. You may use it to help you determine if the bank should be opened from the language specific directory. </td></tr>
</table>
<h3><a class="anchor" id="streamingmanager_lowlevel_location_streamedfiles"></a>
Streamed Audio Files</h3>
<p>Streamed file references are stored in banks as integer IDs. The real file paths of the converted audio files that are meant to be streamed can be found in the SoundBanksInfo.xml file, generated along with the banks (refer to SoundBanksInfo.xml for details).</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> Selecting "Copy streamed files" in Wwise's SoundBank settings to automatically copy files in the Generated SoundBanks folder of the specific platform(s), renamed with the scheme [ID].[ext]. See Streamed Audio Files for more information. The default file location implementation (<b>CAkFileLocationBase</b>) is meant to be used with the "Copy Loose/Streamed Media" option. </td></tr>
</table>
<p>When the sound engine wants to play a streamed audio file, it calls the ID overload of AK::IAkStreamMgr::CreateAuto(). This propagates down to the ID overload of AK::StreamMgr::IAkLowLevelIOHook::Open(). Along with the ID, it passes an <a class="el" href="struct_ak_file_system_flags.html" title="File system flags for file descriptors mapping.">AkFileSystemFlags</a> structure with the following information:</p>
<ul>
<li>uCompanyID is AKCOMPANYID_AUDIOKINETIC</li>
<li>uCodecID is one of the audio formats defined in AkTypes.h (AKCODECID_XXX).</li>
<li>bIsLanguageSpecific flag that is true when the file needs to be searched for in a location that depends on the current game language, false otherwise.</li>
</ul>
<h1><a class="anchor" id="streamingmanager_lowlevel_interface"></a>
I/O Transfer Interface</h1>
<p>Once file location has been resolved, the Stream Manager hands the file descriptor to the appropriate streaming device, which interacts with the Low-Level I/O system through its own I/O hook. The first thing it does is to query the low-level block size constraint, by calling AK::StreamMgr::IAkLowLevelIOHook::GetBlockSize(). Then, every input data transfer is executed through the hook's Read() method, and output through the hook's Write() method. When the stream is destroyed, AK::StreamMgr::IAkLowLevelIOHook::Close() is called.</p>
<p>Each of these methods are passed the same file descriptor that was filled by the File Location Resolver.</p>
<h2><a class="anchor" id="streamingmanager_lowlevel_interface_devicesspecificity"></a>
High-Level Devices Specificity</h2>
<p>The current implementation of the Stream Manager defines a single type of I/O hook, which uses asynchronous handshaking with the Low-Level I/O.</p>
<p><code>AK::StreamMgr::CreateDevice()</code> returns a device ID that is set in the file descriptor structure by the File Location Resolver.</p>
<p>The following section describes the deferred I/O hook.</p>
<h2><a class="anchor" id="streamingmanager_lowlevel_interface_devicesspecificity_AK_SCHEDULER_DEFERRED_LINED_UP"></a>
Deferred I/O Hook</h2>
<p>The Stream Manager creates a streaming device which interacts with the Low-Level I/O system through the <code><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook.html">AK::StreamMgr::IAkLowLevelIOHook</a></code> interface.</p>
<p>The deferred interface is meant to be used with Low-Level I/O implementations that handle multiple transfer requests at the same time. It defines 4 methods, <code>AK::StreamMgr::IAkLowLevelIOHook::BatchOpen()</code>,<code>AK::StreamMgr::IAkLowLevelIOHook::BatchRead()</code>, <code>AK::StreamMgr::IAkLowLevelIOHook::BatchWrite()</code> and <code>AK::StreamMgr::IAkLowLevelIOHook::BatchCancel()</code>. BatchRead() and BatchWrite() should return immediately, and notify the streaming device when one or more transfers are complete through the provided callback function. See details about the BatchOpen in the section Deferred Opening.</p>
<p>You specify the maximum number of concurrent I/O transfers that the streaming device may send to the Low-Level I/O in its initialization settings (AkDeviceSettings::uMaxConcurrentIO).</p>
<p>For each transfer request sent to <code>AK::StreamMgr::IAkLowLevelIOHook::BatchRead()</code> or <code>AK::StreamMgr::IAkLowLevelIOHook::BatchWrite()</code>, you must fill in a list of results indicating if each dispatch succeeded, with AK_Success, or failed, with AK_Fail. You must also return AK_Success if all of the requests were successfully dispatched, or AK_Fail if any of the dispatches failed. The Low-Level I/O system will investigate the list of dispatch results to identify which transfer failed only if AK_Fail is returned.</p>
<p>Similarly, the callback function must be provided a list of results of each transfer, and each value must be AK_Success if the corresponding transfer successfully completed, or AK_Fail otherwise.</p>
<p>If any transfer is marked as AK_Fail when dispatching or completing transfers, the corresponding stream will be destroyed, and an "I/O error" notification will appear in the transfer log.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> If you mark a transfer with a dispatch result of AK_Fail from <code>AK::StreamMgr::IAkLowLevelIOHook::BatchRead()</code> or <code>AK::StreamMgr::IAkLowLevelIOHook::BatchWrite()</code>, the streaming device will not be waiting for the callback function for that transfer, and you should therefore <b>not</b> call it. </td></tr>
</table>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> AkDeviceSettings::uMaxConcurrentIO represents the <em>maximum</em> number of transfer requests that the device may post to the Low-Level I/O. The device's scheduler decides to post transfer requests only when clients of the Stream Manager call AK::IAkStdStream::Read()/Write(), or when a running automatic stream's buffering is below the buffering target (AkDeviceSettings::fTargetAutoStmBufferLength, refer to <a class="el" href="streamingmanager_settings.html">Audiokinetic Stream Manager Initialization Settings</a> for more details on the target buffering length). </td></tr>
</table>
<p>The streaming device passes an array of BatchIoTransferItem's to each of <code><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook.html">AK::StreamMgr::IAkLowLevelIOHook</a>'s</code> functions. This structure contains information on each transfer, including the <a class="el" href="struct_ak_file_desc.html">AkFileDesc</a>, <a class="el" href="struct_ak_io_heuristics.html">AkIoHeuristics</a>, and an <a class="el" href="struct_ak_async_i_o_transfer_info.html">AkAsyncIOTransferInfo</a>. The <a class="el" href="struct_ak_async_i_o_transfer_info.html">AkAsyncIOTransferInfo</a> structure extends the <a class="el" href="struct_ak_i_o_transfer_info.html">AkIOTransferInfo</a> structure mentioned earlier. <a class="el" href="struct_ak_async_i_o_transfer_info.html">AkAsyncIOTransferInfo</a> includes the address of the buffer to read to or write from, and a pUserData field is provided to help implementers attach metadata to the pending transfer. The <a class="el" href="struct_ak_async_i_o_transfer_info.html">AkAsyncIOTransferInfo</a> structure lives until the callback is called. You must not reference it after you called the callback.</p>
<p>The information contained in the provided <a class="el" href="struct_ak_io_heuristics.html">AkIoHeuristics</a> may be useful if you route reads or writes to your own I/O streaming technology, in order to re-order I/O requests.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> The implementation of the default Stream Manager's scheduler is based on "client heuristics", not on "disk bandwidth 
heuristics". The Stream Manager is not aware of the layout of files on disk. If your own streaming technology permits it, it can use this knowledge to re-order I/O requests to minimize seeking on disk. </td></tr>
</table>
<p>Streaming devices sometimes need to flush data. This may occur when clients of the Stream Manager call <code>AK::IAkAutoStream::SetPosition()</code>, or change the looping heuristics. Sometimes, data may even need to be flushed before the corresponding transfer is complete. This is more likely to occur when AkDeviceSettings::uMaxConcurrentIO and AkDeviceSettings::fTargetAutoStmBufferLength are large. The deferred I/O hook API provides an entry point to get notified when this occurs: BatchCancel(). When the streaming device needs to flush data that is associated with one or more I/O transfers that are still pending in the Low-Level I/O, it internally tags the transfers as "cancelled", calls <code>AK::StreamMgr::IAkLowLevelIOHook::BatchCancel()</code>, and waits for the callback to be called. BatchCancel() is only used to notify the Low-Level I/O, and it may or may not do anything. The streaming device knows what transfers need to be cancelled, so if you let them complete normally instead of cancelling them, they will be flushed upon completion. <b>In all cases, the callback function must be called in order to notify the streaming device that it can freely dispose of the I/O transfer information and buffer.</b></p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> <b>Ensure that you never call the callback twice for a given transfer.</b> </td></tr>
</table>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b><ul>
<li>If you implement a queue in the Low-Level I/O, you may use BatchCancel() to dequeue the request. If you are able to dequeue it, then you may call the callback function directly from within BatchCancel().</li>
<li>You should not block on an physical device controller inside BatchCancel(). This could block clients of the Stream Manager. </li>
</ul>
</td></tr>
</table>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> When calling the callback function of a cancelled transfer, you must pass AK_Success. Anything else will be considered as an I/O error and the associated stream(s) will be terminated. </td></tr>
</table>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> <code>AK::StreamMgr::IAkLowLevelIOHook::BatchCancel()</code> may be called from any thread. Consequently, you must be extremely cautious with locking in the Low-Level I/O if you implement <code>AK::StreamMgr::IAkLowLevelIOHook::BatchCancel()</code>. In particular, you need to avoid race conditions between calling back pCallback from BatchCancel() and from the normal I/O completion code path. More details can be found in the function's description. </td></tr>
</table>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> Do not feel compelled to implement <code>AK::StreamMgr::IAkLowLevelIOHook::BatchCancel()</code> just for the sake of it. Because of locking issues, it can sometimes be more costly to try to cancel requests than to let them complete normally. </td></tr>
</table>
<h2><a class="anchor" id="streamingmanager_lowlevel_interface_otherconsiderations"></a>
Other Considerations</h2>
<h3><a class="anchor" id="streamingmanager_lowlevel_interface_otherconsiderations_getblocksize"></a>
Block Size (GetBlockSize())</h3>
<p>As mentioned before, users of the Stream Manager must take low-level I/O constraints on allowed transfer sizes into account. The most common constraint is that these sizes be a multiple of some value. This value is returned by AK::StreamMgr::IAkLowLevelIOHook::GetBlockSize() for a given file descriptor. For example, a file opened in WindowsÂ® with the FILE_FLAG_NO_BUFFERING flag must be read with sizes that are a multiple of the sector size. The AK::StreamMgr::IAkLowLevelIOHook::GetBlockSize() method returns the sector size. If, on the other hand, a Win32 file is not opened with that flag, AK::StreamMgr::IAkLowLevelIOHook::GetBlockSize() should return 1, so as not to constrain clients of the Stream Manager.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> AK::StreamMgr::IAkLowLevelIOHook::GetBlockSize() must never return 0. </td></tr>
</table>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> The burden of dealing with the low-level block size constraint is passed to the client of the Stream Manager. Larger block size values result in more wasted streaming data by the sound engine. You should use a low-level block size of 1 unless the platform's I/O system has specific alignment constraints or unless it helps you improve I/O bandwidth performance significantly. </td></tr>
</table>
<h3><a class="anchor" id="streamingmanager_lowlevel_interface_otherconsiderations_getdesc"></a>
Profiling</h3>
<p>AK::StreamMgr::IAkLowLevelIOHook::GetDeviceDesc() is used for profiling in Wwise. The information provided by the default implementation of the Low-Level I/O is what is actually seen in Wwise when profiling.</p>
<p>AK::StreamMgr::IAkLowLevelIOHook::GetDeviceData() is similar, but it is called at every profiling frame. The value it returns appears in the Custom Parameter column of the Streaming Device tab.</p>
<h1><a class="anchor" id="streamingmanager_lowlevel_default_implementation_walkthrough"></a>
Sample Default Implementation Walkthrough</h1>
<p>Default implementations of the Low-Level I/O are provided with the Wwise SDK. They are located in the samples/SoundEngine/ directory.</p>
<h2><a class="anchor" id="streamingmanager_lowlevel_default_implementation_walkthrough_overview"></a>
Classes Overview</h2>
<p>The figure below is a class diagram that represents the Low-Level I/O samples and their relation with the Low-Level I/O API.</p>
<div class="image">
<img src="LowLevelIO_samples.gif" alt=""/>
</div>
<p>CAkDefaultIOHookDeferred implements the File Location Resolver API (<code><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_file_location_resolver.html">AK::StreamMgr::IAkFileLocationResolver</a></code>) and the deferred I/O hook (<code><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook.html">AK::StreamMgr::IAkLowLevelIOHook</a></code>) or an adapter-interface to the non-batched deferred I/O hook (<code>AK::StreamMgr::IAkIOHookDeferred</code>). Either implementation can be used alone, in a single-device I/O system. <b>CAkDefaultIOHookDeferred::Init()</b> creates a streaming device in the Stream Manager, passing it the device settings, and store the returned device ID.</p>
<p>Also, this device registers itself to the Stream Manager as the one and only File Location Resolver. But, this is <b>only if</b> there is not already a File Location Resolver registered to the Stream Manager.</p>
<p>The following figure is a block diagram that represents a single-device I/O system. "Low-Level IO" is any class that implements the File Location Resolver API as well as one of the I/O hook APIs. It can be any of these sample classes:</p><ul>
<li>CAkDefaultIOHookDeferred</li>
<li>CAkFilePackageIOHookDeferred</li>
</ul>
<div class="image">
<img src="LowLevelIO_SingleDevice.gif" alt=""/>
</div>
<p>Here is how you would initialize the I/O system with <b>CAkDefaultIOHookDeferred</b> used alone (without error handling).</p>
<div class="fragment"><div class="line"><span class="comment">// Create the Stream Manager.</span></div>
<div class="line"><a class="code" href="struct_ak_stream_mgr_settings.html">AkStreamMgrSettings</a> stmSettings;</div>
<div class="line">AK::StreamMgr::GetDefaultSettings( stmSettings );</div>
<div class="line">AK::StreamMgr::Create( stmSettings );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a streaming device.</span></div>
<div class="line"><a class="code" href="struct_ak_device_settings.html">AkDeviceSettings</a> deviceSettings;</div>
<div class="line">AK::StreamMgr::GetDefaultDeviceSettings( deviceSettings );</div>
<div class="line"> </div>
<div class="line">CAkDefaultIOHookDeferred lowLevelIO;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Init registers lowLevelIO as the File Location Resolver if it was not already defined, and creates a streaming device.</span></div>
<div class="line">lowLevelIO.Init( deviceSettings );</div>
</div><!-- fragment --><p>The File Location Resolver implementation inside the device uses the services of <b>CAkFileLocationBase</b>, from which it also inherits. For more details on the file location strategy implemented in <b>CAkFileLocationBase</b>, refer to Basic File Location below.</p>
<p>Read section Deferred I/O Hook Walkthrough below for more details on the implementation of the default deferred I/O hook.</p>
<p>There is another class, written as a template, which adds the ability to manage file packages to classes that implement both <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_file_location_resolver.html">AK::StreamMgr::IAkFileLocationResolver</a> and <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook.html">AK::StreamMgr::IAkLowLevelIOHook</a> (like <b>CAkDefaultIOHookDeferred</b>). It is <b>CAkFilePackageLowLevelIO&lt;&gt;</b>. File packages are files that are created using the <a class="el" href="namespace_a_k.html" title="Audiokinetic namespace.">AK</a> File Packager utility. Refer to section Sample File Package Low-Level I/O Implementation Walkthrough below for more information about file package handling in the Low-Level I/O. Class <b>CAkFilePackageIOHookDeferred</b> is a concrete definition of <b>CAkDefaultIOHookDeferred</b>, enhanced with file package management.</p>
<p>If you want to implement an I/O system with more than one device, you need to register a separate File Location Resolver to the Stream Manager, which task is to dispatch management of files to appropriate devices. The SDK provides a canvas to implement this functionality: <b>CAkDefaultLowLevelIODispatcher</b>. Refer to Multi-Device I/O System for more details on multi-device I/O systems.</p>
<h2><a class="anchor" id="streamingmanager_lowlevel_default_implementation_walkthrough_file_location"></a>
Basic File Location</h2>
<p>Files used by the sound engine are opened either with IDs (used for both streamed audio files and SoundBanks) or with strings (generally reserved for SoundBanks). <b>CAkDefaultIOHookDeferred</b> inherit from <b>CAkFileLocationBase</b>, which exposes methods to set global paths (<b>SetBasePath()</b>, <b>AddBasePath()</b>, <b>SetBankPath()</b>, <b>SetAudioSrcPath()</b>). Both overloads of <b>CAkDefaultIOHookDeferred::Open()</b> call <b>CAkFileLocationBase::GetFullFilePath()</b>, to create a full file name that can be used with native file open functions. The base path is prepended first. Then, if the file is a SoundBank, the SoundBank path is added. If it is a streamed audio file, the audio source path is added. In both cases, if it is a file with a location dependent on the current language, the language directory name is added.</p>
<p>If the string overload is used, the file name string is appended to this path.</p>
<p>In the ID overload, only Audiokineticâ€™s file IDs are resolved. A game that uses the ID overload needs to change the implementation according to its ID mapping scheme. The mapping scheme of <b>CAkFileLocationBase</b> is the following: it creates a string based on the file ID, and appends an extension that depends on the file type (specified with the Codec ID). This is compatible with the streamed files naming convention used by the "Copy Streamed Files" post-generation step soundbank setting. Refer to the Wwise Help for more information about the soundbank settings.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><p class="starttd"><b>Note:</b> When the option "Use SoundBank names" of the SoundBank settings is not selected, Wwise generates bank files with names' in the format [ID].bnk. Therefore, explicit bank loads by ID (through the ID overload of AK::SoundEngine::LoadBank()) and implicit bank loads triggered from AK::SoundEngine::PrepareEvent() will be mapped properly in the Default Low-Level I/O. When "Use SoundBank names" is selected, Wwise generates bank files with their original names (bank_name.bnk). Implicit bank loading, and explicit bank loading by string will be mapped properly. However, explicit bank loading by ID will not work, because the Default Low-Level I/O will try to open a file named [ID].bnk, which does not exist.</p>
<p class="intertd">Refer to Using SoundBank Names for a discussion on the "Use SoundBank names" option from an SDK point of view, or the Wwise Help for SoundBank settings in general.</p>
<p class="endtd">Likewise, the Default Low-Level I/O opens streamed audio files with names in the format [ID].[ext]. The [ext] is an extension that depends on the audio format. It is possible to tell Wwise to automatically copy all streamed audio files in the Generated SoundBank path, with the [ID].[ext] file name format, at the end of the SoundBank generation (refer to Streamed Audio Files and the Wwise Help). </p>
</td></tr>
</table>
<p>After the full file path is obtained, <b>CAkDefaultIOHookDeferred::Open()</b> opens the file directly using the system API (wrapped in helpers implemented in the platform-specific sample file AkFileHelpers.h).</p>
<p>From the game code you can set the base, SoundBank, audio source, and language-specific paths by using the methods of <b>CAkFileLocationBase</b> mentioned above. Refer to the sample code of the Default Low-Level I/O Implementation for more information.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><p class="starttd"><b>Tip:</b> The sound engine does not know when banks need to be loaded from a language-specific directory. Therefore, it always calls AK::IAkStreamMgr::CreateStd() with the bIsLanguageSpecific flag of the <a class="el" href="struct_ak_file_system_flags.html" title="File system flags for file descriptors mapping.">AkFileSystemFlags</a> structure set to true first, then to false if the first call failed. The sample default implementation of the Low-Level I/O blindly tries to open the file from the current language-specific directory, which is of course inefficient because of the failed calls made to fopen(), which should be avoided.</p>
<p class="endtd">You should always reimplement the Low-Level I/O to fit your needs. If you know the names of the language-specific SoundBanks, or you defined a nomenclature to identify them, load them from the correct folders early in the process. </p>
</td></tr>
</table>
<h2><a class="anchor" id="streamingmanager_lowlevel_default_implementation_walkthrough_hook_deferred"></a>
Deferred I/O Hook Walkthrough</h2>
<p>Generally, asynchronous file read APIs on platforms require that you pass a platform-specific structure to fread() (OVERLAPPED on Windows), and keep it for the whole duration of the I/O operation, until a callback function gets called to notify you that I/O is complete.</p>
<p>The implementation is somewhat similar on all platforms. <b>CAkDefaultIOHookDeferred</b> allocates an array of these platform-specific structures in its own memory pool. When <b>CAkDefaultIOHookDeferred::Read()</b> is called, it finds the first structure that is free, marks it as "used", fills it with the information provided in <a class="el" href="struct_ak_async_i_o_transfer_info.html">AkAsyncIOTransferInfo</a>, and passes it to fread(). It also passes a local static callback function whose signature is compatible with the platform's asynchronous fread() function. In this function, it determines if the operation was successful, releases the platform-specific I/O structure, and calls back the streaming device.</p>
<p>Obtaining and releasing the platform-specific I/O structure from the array must be atomic, as we need to avoid race conditions between Read()/Write() and the system's callback.</p>
<p>Some platforms expose a service to cancel I/O requests that were already sent to the kernel. When this is the case, it is called from within <b>CAkDefaultIOHookDeferred::Cancel()</b>. On Windows, <b>CancelIO()</b> cancels all requests for a given file handle. Therefore, we must ensure that the streaming device wants to cancel all requests for a given file before calling this function, by looking at the argument io_bCancelAllTransfersForThisFile. If it doesn't, then Cancel() does nothing: we just wait until requests are complete. The streaming device knows which ones it needs to discard.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> Do not cancel requests that were not cancelled explicitly by the streaming device. If you do, you may end up feeding it with invalid or corrupted data, which may crash the sound engine. </td></tr>
</table>
<h2><a class="anchor" id="streamingmanager_lowlevel_default_implementation_walkthrough_multidevice"></a>
Multi-Device I/O System</h2>
<p>The following figure represents a multi-device I/O system.</p>
<div class="image">
<img src="LowLevelIO_MultiDevices.gif" alt=""/>
</div>
<p>What you need to do to work with multiple streaming devices is to instantiate and register a File Location Resolver that is distinct from the device's low-level I/O hooks. The purpose of this object is to dispatch files to the appropriate device. The strategy you employ to decide which device handles which files is yours to define. You may use <b>CAkDefaultLowLevelIODispatcher</b> as a canvas. The default implementation uses brute force: each device is asked to open the file until one of them succeeds. Thus these devices must also implement the <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_file_location_resolver.html">AK::StreamMgr::IAkFileLocationResolver</a> interface. It can be any of the samples provided in the SDK:</p><ul>
<li>CAkDefaultIOHookDeferred</li>
<li>CAkFilePackageIOHookDeferred</li>
</ul>
<p>Here's how you would instantiate both a deferred device and a file package device in a multi-device system (although this example is not useful in practice).</p>
<div class="fragment"><div class="line"><span class="comment">// Create Stream Manager.</span></div>
<div class="line"><a class="code" href="struct_ak_stream_mgr_settings.html">AkStreamMgrSettings</a> stmSettings;</div>
<div class="line">AK::StreamMgr::GetDefaultSettings( stmSettings );</div>
<div class="line">AK::StreamMgr::Create( stmSettings );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and register the File Location Resolver.</span></div>
<div class="line">CAkDefaultLowLevelIODispatcher lowLevelIODispatcher;</div>
<div class="line">AK::StreamMgr::SetFileLocationResolver( &amp;lowLevelIODispatcher );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a first device.</span></div>
<div class="line">CAkDefaultIOHookDeferred hookIODeferred;</div>
<div class="line"><a class="code" href="struct_ak_device_settings.html">AkDeviceSettings</a> deviceSettings1;</div>
<div class="line">AK::StreamMgr::GetDefaultDeviceSettings( deviceSettings1 );</div>
<div class="line">hookIODeferred.Init( deviceSettings1 );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add it to the global File Location Resolver.</span></div>
<div class="line">lowLevelIODispatcher.AddDevice( hookIODeferred );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a second device with file package management.</span></div>
<div class="line">CAkFilePackageIOHookDeferred hookIOFilePackage;</div>
<div class="line"><a class="code" href="struct_ak_device_settings.html">AkDeviceSettings</a> deviceSettings2;</div>
<div class="line">AK::StreamMgr::GetDefaultDeviceSettings( deviceSettings2 );</div>
<div class="line">hookIOFilePackage.Init( deviceSettings2 );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add it to the global File Location Resolver.</span></div>
<div class="line">lowLevelIODispatcher.AddDevice( hookIOFilePackage );</div>
</div><!-- fragment --><table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> You should only use multiple devices with multiple physical devices. </td></tr>
</table>
<h1><a class="anchor" id="streamingmanager_lowlevel_filepackage_implementation_walkthrough"></a>
Sample File Package Low-Level I/O Implementation Walkthrough</h1>
<h2><a class="anchor" id="streamingmanager_lowlevel_filepackage_implementation_walkthrough_intro"></a>
General Description</h2>
<p>The <b>CAkFilePackageLowLevelIO&lt;&gt;</b> class is a layer above the Default low-level I/O hooks. It extends the latter by being able to load a file that was generated by the sample File Packager (see File Packager Utility). It uses a more advanced strategy to resolve the IDs into file descriptors. File packages are composed of many concatenated files (streamed audio files and bank files), and their header contains information about these files.</p>
<p>Refer to the File Package Low-Level I/O Implementation for the sample code. You can use the File Package Low-Level I/O "as-is" (<b>CAkFilePackageLowLevelIODeferred</b>), along with its counterpart, the File Packager utility. Or, simply consider them as a proof of concept for the implementation of an advanced file location resolving method.</p>
<p>The File Package Low-Level I/O exposes the method <b>CAkFilePackageLowLevelIO::LoadFilePackage()</b>, whose argument is the file name of a package that was generated with the sample File Packager. It opens it using the services of the default implementation, then parses the header and builds the look-up tables. You may load as many file packages as you want. <b>LoadFilePackage()</b> returns an ID that you can use with <b>UnloadFilePackage()</b> to unload it.</p>
<p>The class <b>CAkFilePackage</b> represents a loaded file package, and all data structures and code to handle file look-up is defined in class <b>CAkFilePackageLUT</b>. The <b>CAkFilePackageLowLevelIO&lt;&gt;</b> class overrides some of the methods of the default I/O hooks, to invoke the look-up services of <b>CAkFilePackageLUT</b>. When a file descriptor is not found, or when the request does not concern a file descriptor that belongs to the file package, then the default implementation is called.</p>
<h2><a class="anchor" id="streamingmanager_lowlevel_filepackage_implementation_walkthrough_filelocation"></a>
File Location</h2>
<p>The idea behind file look-up inside packages is the following: you get a file handle from the platform's file open function only once, and then at each call to AK::StreamMgr::IAkLowLevelIOHook::Open(), you simply return a file descriptor that uses this file handle, but with an offset that corresponds to the offset of the original file inside the file package (using the uSector field of the file descriptor <a class="el" href="struct_ak_file_desc.html">AkFileDesc</a>). This also has the benefit of allowing more control over the placement of files on disk.</p>
<p>The File Packager utility carefully prepares its header so that the Low-Level I/O only has to cast some pointers to obtain the look-up tables it contains, that is, one for the streamed audio files, and one for the bank files. Look-up tables are arrays of the following structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>AkFileEntry </div>
<div class="line">{</div>
<div class="line">    AkFileID    fileID;     <span class="comment">// File identifier. </span></div>
<div class="line">    AkUInt32    uBlockSize; <span class="comment">// Size of one block, required alignment (in bytes).</span></div>
<div class="line">    AkInt64     iFileSize;  <span class="comment">// File size in bytes. </span></div>
<div class="line">    AkUInt32    uStartBlock;<span class="comment">// Start block, expressed in terms of uBlockSize. </span></div>
<div class="line">    AkUInt32    uLanguageID;<span class="comment">// Language ID. AK_INVALID_LANGUAGE_ID if not language-specific. </span></div>
<div class="line">};</div>
</div><!-- fragment --><p>The table key is the file's fileID. However, corresponding files of different languages have the same fileID, but a different uLanguageID. The File Packager always sorts the file entries by the fileID first, then by the uLanguageID. In <b>CAkFilePackageLowLevelIO::Open()</b>, the ID is passed to <b>CAkFilePackageLUT::LookupFile()</b> (in the string version of Open(), the string is hashed first, using the service of the sound engine API, AK::SoundEngine::GetIDFromString()). <b>CAkFilePackageLUT::LookupFile()</b> selects the appropriate table to search, based on the flags' uCodecID, and performs a binary search by the fileID and uLanguageID keys. If it finds a match, the file entry's address is returned to <b>CAkFilePackageLowLevelIO::Open()</b>, which gathers the necessary information to fill the file descriptor (<a class="el" href="struct_ak_file_desc.html">AkFileDesc</a>).</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Tip.gif" alt="" class="inline"/></td><td><b>Tip:</b> Each file package is searched until a match is found. If you use a file package with soundbanks exclusively, and another with streamed files exclusively, then you may modify the implementation to use the <a class="el" href="struct_ak_file_system_flags.html" title="File system flags for file descriptors mapping.">AkFileSystemFlags</a> to only look up files in the proper file package, once. </td></tr>
</table>
<p>The handle of the file descriptor, hFile, is that of the file package. The file size, iFileSize, was stored directly in the file entry, and so was the starting block, uSector.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> Recall that the Stream Manager does not expect a byte offset from the beginning of the file represented by the handle hFile, but rather an offset in terms of blocks ("sectors"). The block size represents the granularity of file positions. The current version of the File Packager uses the same block size for all files, which is specified at the time of generation (using -blocksize switch - refer to Wwise Help for more details on the File Packager's command line arguments). It performs zero-padding so that concatenated files always start on a block boundary. </td></tr>
</table>
<p>The File Package low-level I/O uses the uCustomParamSize field of the file descriptor to store the block size. This has 2 purposes:</p><ul>
<li>easy access to its block size;</li>
<li>distinguish file descriptors that belong to the file package (uCustomParamSize == 0 means that the file was not found in the package). For example, the file handle (which is shared between all files of a package) is not closed in CAkFilePackageLowLevelIO::Close() when the file is part of a package.</li>
</ul>
<h2><a class="anchor" id="streamingmanager_lowlevel_filepackage_implementation_walkthrough_languages"></a>
Managing Languages</h2>
<p>Since Wwise version 2011.2, the current language is set on the default Stream Manager module, using AK::StreamMgr::SetCurrentLanguage(), defined in <a class="el" href="_ak_stream_mgr_module_8h.html">AkStreamMgrModule.h</a>. Pass the name of the language, <b>without a trailing slash or backslash</b>.</p>
<p>The default low-level I/O implementations inheriting from <b>CAkFileLocationBase</b> get the language name from the Stream Manager, and append it to the base path. The language name should therefore correspond to the name of the directory where are stored localized assets for this particular language.</p>
<p>File packages generated by the File Packager utility may contain one or many versions of the same asset in different languages. Their header contains a string map of language names. The File Package Low-Level I/O listens to language changes on the Stream Manager, and uses the current language name to look-up the correct localized version of packaged localized assets. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespace_a_k_1_1_stream_mgr_a50fe8111fcb883651390fab6e9dc5ebc_html_a50fe8111fcb883651390fab6e9dc5ebc"><div class="ttname">AK::StreamMgr::GetDefaultSettings</div><div class="ttdeci">AKSOUNDENGINE_API void GetDefaultSettings(AkStreamMgrSettings &amp;out_settings)</div></div>
<div class="ttc" id="astruct_ak_device_settings_html"><div class="ttname"><a href="struct_ak_device_settings.html">AkDeviceSettings</a></div><div class="ttdef"><b>Definition:</b> AkStreamMgrModule.h:59</div></div>
<div class="ttc" id="a_common_2_ak_types_8h_adff75ad09d4237d128c034afd17f3b35_html_adff75ad09d4237d128c034afd17f3b35"><div class="ttname">AkFileID</div><div class="ttdeci">AkUInt32 AkFileID</div><div class="ttdoc">Integer-type file identifier.</div><div class="ttdef"><b>Definition:</b> AkTypes.h:159</div></div>
<div class="ttc" id="a_ak_numeral_types_8h_a3f2533eb6fb2011f230af7474daabc6c_html_a3f2533eb6fb2011f230af7474daabc6c"><div class="ttname">AkInt64</div><div class="ttdeci">int64_t AkInt64</div><div class="ttdoc">Signed 64-bit integer.</div><div class="ttdef"><b>Definition:</b> AkNumeralTypes.h:44</div></div>
<div class="ttc" id="anamespace_a_k_1_1_stream_mgr_af9d67dd0e502e5603a2921099916e2ab_html_af9d67dd0e502e5603a2921099916e2ab"><div class="ttname">AK::StreamMgr::Create</div><div class="ttdeci">AKSOUNDENGINE_API IAkStreamMgr * Create(const AkStreamMgrSettings &amp;in_settings)</div></div>
<div class="ttc" id="anamespace_a_k_1_1_stream_mgr_a7d01e09a9bb6b6d34c2bb8f4c8995214_html_a7d01e09a9bb6b6d34c2bb8f4c8995214"><div class="ttname">AK::StreamMgr::GetDefaultDeviceSettings</div><div class="ttdeci">AKSOUNDENGINE_API void GetDefaultDeviceSettings(AkDeviceSettings &amp;out_settings)</div></div>
<div class="ttc" id="anamespace_a_k_1_1_stream_mgr_ab5c2340963ac5ff81e49969b74ef2520_html_ab5c2340963ac5ff81e49969b74ef2520"><div class="ttname">AK::StreamMgr::SetFileLocationResolver</div><div class="ttdeci">AKSOUNDENGINE_API void SetFileLocationResolver(IAkFileLocationResolver *in_pFileLocationResolver)</div></div>
<div class="ttc" id="a_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce_html_a39c6c5d577901802ca77775760b704ce"><div class="ttname">AkUInt32</div><div class="ttdeci">uint32_t AkUInt32</div><div class="ttdoc">Unsigned 32-bit integer.</div><div class="ttdef"><b>Definition:</b> AkNumeralTypes.h:38</div></div>
<div class="ttc" id="astruct_ak_stream_mgr_settings_html"><div class="ttname"><a href="struct_ak_stream_mgr_settings.html">AkStreamMgrSettings</a></div><div class="ttdef"><b>Definition:</b> AkStreamMgrModule.h:50</div></div>
</body>
</html>

