<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tips to Reduce Memory Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tips to Reduce Memory Usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>It can be challenging to trim down memory usage to fit your required limit. Here are a few tips to help reduce memory usage:</p>
<ul>
<li>Object Memory</li>
<li>Processing Memory</li>
<li>Media Memory (SoundBanks)</li>
</ul>
<h1><a class="anchor" id="goingfurther_optimizingmempools_reducing_memory_object"></a>
Object Memory</h1>
<p>Object memory usage is directly impacted by the number of sounds and events loaded in-memory and the amount of game objects. It contains all the properties of the objects in your project necessary to implement the behaviors of the sound design. It also contains all the game objects and their related information (game syncs values, position, orientation, and so on). The more banks are loaded, the more memory needs to be allocated. The size needed depends only on the number of sounds that can possibly be played in one scenario, level, map, game area, or the like. There are practices that can help reduce these allocations:</p><ul>
<li><b>Split big SoundBanks with lots of sound structures and Events into smaller SoundBanks</b>. For guidance, you can check the Advanced Profiler's SoundBanks tab to see in the Object Memory column how much memory each SoundBank is taking. Then you can load and unload SoundBanks dynamically as needed. Think strategically in dividing them. For example, in dividing dialog SoundBanks, avoid creating ones with all lines for a single character. Instead, group the dialog contextually.</li>
<li><b>Use the AK::SoundEngine::ExecuteActionOnEvent API to reduce the number of events</b>. Play/Stop pairs can be replaced by a single Play event and a call to ExecuteActionOnEvent for the Stop and the Pause/Resume (it could be the same Play event).</li>
<li><b>Tightly manage your game objects</b>. Unregister them as soon as their role is finished. Avoid keeping a pool of unused game objects alive; there is absolutely no gain in doing this, but it can cost in memory. For example, imagine an NPC dies. Unregister its game object; do not reuse it for something else. Register a brand new one when needed. As a general rule, if you have thousands of game objects alive, it is too many.</li>
<li><b>Do not use Actor-Mixers only to organize sounds</b>. Folders and Work Units do not take memory, Actor-Mixers do. Unless they DO share similar properties that are not the default, then you save memory because the property is there once only. Of course, this also depends if the Actor-Mixer is referenced by events (such as SetVolume or SetPitch).</li>
<li><b>Try to reduce the size and complexity of large hierarchies</b>. A common example of a large hierarchy would be an "Impact" hierarchy or a "Footstep" hierarchy. With lots of variables, it can grow large and take lots of memory for structure. Here are a few ways to reduce such a hierarchy:<ul>
<li>Use RTPCs if the only thing changing in the Switch is a simple property (same samples but different volume/pitch/randomizer etc.).</li>
<li>Split your Switch Container hierarchy into multiple banks. In the SoundBank Manager, when you include a Switch container, all its sub-branches are also included. However, you can exclude some of the branches manually in the SoundBank Editor view, in the Game Sync tab or in the Edit tab. For example, in a "Footstep" hierarchy, the first Switch variable could be the Surface Type. You could then split the Switch across different SoundBanks and load them depending on the context. You could have a main "Footstep" SoundBank containing the surfaces that are encountered throughout the game, such as concrete and metal stairs in a city environment, and other contextual SoundBanks with specific surfaces, such as mud being used only in one scene/section of the game.</li>
</ul>
</li>
<li><b>Use "external sources" to reduce the overhead of sounds that do not need as much control as offered by the Wwise Actor-Mixer hierarchy</b>. This is usually appropriate for voice-overs.</li>
</ul>
<h1><a class="anchor" id="goingfurther_optimizingmempools_reducing_memory_processing"></a>
Processing Memory</h1>
<p>The memory in the Processing category is used to play sounds. It contains buffers to decompress, apply effects, and mix the audio sources. It is directly influenced by the number of sounds playing at the same time. It is also influenced by the number and type of effects that are used at the same time. To trim this down, you need to ask yourself how many sounds you want to hear at the same time. Some games will rarely have a scenario where more than 10 sounds are heard, others will have hundreds. You need to consider your worst case.</p>
<p>As a guideline, we have done some profiling on some games (on Xbox One) and had the following numbers:</p><ul>
<li>1 MB will let you play approximately 42 voices</li>
<li>2 MB will let you play approximately 96 voices Although it scales mostly linearly, it really depends on which codec is used, how many effects, and other such factors. For example, using the Vorbis codec will use around 50% more memory per voice depending on the quality settings. Imagine 170 sounds at the same time: it is probably unintelligible and, therefore, useless. However, it takes some experimentation to find an ideal real number of voices for your game. Use the Memory tab of the profiler, profile multiple scenarios in your game, and note how much is used in resources.</li>
</ul>
<p>To reduce the memory used for processing, you need to reduce the number of simultaneous voices. This can be done using:</p><ul>
<li><b>Playback Limits</b> (Advanced Settings). For example, do you really need to hear 50 bullet ricochets? If not, maybe limit those sounds to say 15. <table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> You can set limits on busses as well. </td></tr>
</table>
</li>
<li><b>Priority</b> (Advanced Settings). For example, bullets could be less important than dialog. This means that bullets would get kicked first if there are too many sounds. Use in conjunction with Playback Limits.</li>
<li><b>Distance-based priority offset</b> (Advanced Settings). Objects that are far are usually less important than closer ones. For example, again with bullets, we don't need to hear bullets that are 10 meters away if there are 15 other bullets sounds closer than that.</li>
<li><b>Below Threshold Behavior</b> (Advanced Settings). The least expensive option (CPU and memory) is "Kill Voice", which is useful for non-looping sounds. The second preferred option is "Send To Virtual" "Play from beginning", then "Send To Virtual" "Resume" and then "Send To Virtual" "Play from elapsed time". "Continue to play" and "Play from elapsed time" are the most costly options, and Wwise's default value is "Continue To Play".</li>
<li><b>Volume Threshold</b> (Project Settings). This will help kill the sounds too faint to be heard. This goes hand in hand with the Below Threshold Behavior and also the Attenuation settings (farther usually means fainter). <table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> You can change the volume threshold programmatically at run-time. You may use this in game locations that are more process-heavy in order to send more voices to their "under volume threshold" state. </td></tr>
</table>
</li>
<li><b>A change to the used codec settings</b> (Conversion Settings). Vorbis needs extra memory to decompress audio. Different parameters can increase or reduce the amount needed. However, think carefully about the tradeoff: using a different codec or a weaker compression ratio will relieve the Processing memory load but at the cost of larger files in memory, if they're in loaded banks. In some cases it's better to see an extra 500 KB in Processing memory usage to save a few MBs on Media memory and, therefore, on the overall audio budget.</li>
<li><b>Fewer or lower quality</b>. Some effects need a lot of memory to be processed. One very common memory consumer is the Reverb effect, in any of its available flavors. Realistically, your game should have very few reverbs running concurrently. As a rule, we suggest less than 4. Also, reducing the quality or length of the reverb will help.</li>
</ul>
<h1><a class="anchor" id="goingfurther_optimizingmempools_reducing_memory_media"></a>
Media Memory (SoundBanks)</h1>
<p>The amount of memory taken by SoundBanks is mostly dictated by the sound data in it. Controlling the amount of memory used by your media can be done through:</p><ul>
<li>Splitting big SoundBanks with lots of sound structures and Events into smaller SoundBanks. Load and unload dynamically as needed.</li>
<li>Streaming more sounds from disk (Sounds' properties). Sounds that are latency-sensitive can use prefetch media, which can be pre-loaded, or be streamed into cache on-demand using the PinEventInStreamCache API.</li>
<li>Using the PrepareEvent() API.</li>
<li>Compressing the audio more (Conversion Settings, codec, and so on).</li>
<li>Using a lower sampling rate. Also look at the Automatic Sample Rate Detection feature of the Conversion Settings.</li>
<li>Replacing wind-type sounds with a Soundseed Wind/Woosh plug-in equivalent. Wind ambiance tends to be long loops, which can take a lot of media space. Blades woosh, propellers, wind rushing in a car with open windows, ventilation noises, and so on can be modelled with this plug-in. Also consider non-windy applications: any noisy sound could be modeled. <b>Examples:</b> Ocean waves or the sound of a highway in the distance.</li>
</ul>
<h1><a class="anchor" id="goingfurther_optimizingmempools_tempallocs"></a>
Tuning "Temp Alloc" Memory</h1>
<p>Wwise uses an internal pool of memory to manage some temporary allocations that persist for less than one audio-render tick, which are represented in the Advanced Profiler's Memory tab as "Temp Alloc". These temporary allocations exist for a specific amount of time, have very little overhead, are handled internally by the sound engine, and cannot be forwarded to developer-provided memory allocation hooks. Instead, the only allocations in this regard that are observed by the Advanced Profiler and memory allocation hooks are the larger memory blocks that the temporary allocations are made from. Therefore, it might be desirable to manually tune the management of "Temp Alloc" memory blocks, in order to better optimize memory usage in your game.</p>
<p>During <code>AK::MemoryMgr::Init</code>, <code>AkMemSettings::tempAllocSettings</code> controls the behavior of the memory blocks for each Temp Alloc category. Notably, this includes configuring the size of the memory blocks, the minimum number of blocks that the system keeps allocated at all times, and how many blocks have to be unused for a tick before the system starts freeing memory. You can use <code>AK::GetTempAllocStats()</code> to see how much memory the Temp Alloc system uses in your game at runtime, and better fine tune configuration of the system.</p>
<p>The following are some suggestions depending on your game's requirements, or other behavior observed during profiling:</p><ul>
<li>If you are not concerned about the overhead of allocating and freeing the memory blocks, or the memory fragmentation that is incurred when the memory blocks are freed, it might be desirable to set <code>AK::TempAllocInitSettings::uMinimumBlockSize</code> to a lower value than the default, so that it better matches the memory usage of your game's needs at any given time.</li>
<li>If the allocation and freeing of blocks causes excessive memory fragmentation, you can measure <code>AK::TempAllocStats::uPeakMemUsed</code> to view the Temp Alloc system's peak memory usage, and then ensure that the <code>AK::TempAllocInitSettings::uMinimumBlockCount</code> is set to a high enough value so that all of the blocks you might use are allocated when the sound engine is initialized, and never freed afterward.</li>
<li>If you want to avoid freeing memory blocks without evaluating your peak memory usage, you can set <code>AK::TempAllocInitSettings::uMaximumUnusedBlocks</code> to a high value to ensure that the system can allocate new blocks, but not free them, even during periods of low memory load.</li>
<li>If you are using the Job Manager for audio rendering, as described in Leveraging the Job Manager for Concurrent Execution of Audio Rendering Jobs, the number of memory blocks will increase. This is because the memory blocks are all thread-local, and one memory block is typically allocated by each active worker. It might be desirable to lower <code>AK::TempAllocInitSettings::uMinimumBlockSize</code> so that using more workers does not cause a significant increase in used memory in your game.</li>
<li>If your memory allocation system includes some metadata adjacent to large memory allocations, it might be worth ensuring that the amount of memory allocated by the memory blocks does not cause a significant amount of waste. Given a requested allocation of 2048 KiB, some memory allocation systems might actually map 2112 KiB of memory. However, a requested allocation might of 2047 KiB would map 2048 KiB of memory. The block sizes do not need to be powers of two, or exactly matched to page sizes, so it might be preferable to set <code>AK::TempAllocInitSettings::uMinimumBlockSize</code> to a slightly reduced value than intended in order to mitigate waste in this regard.</li>
</ul>
<p>Some debugging options are available in <code>AK::TempAllocInitSettings</code>. In the Debug and Profile configuration of the sound engine, <code>AK::TempAllocInitSettings::bDebugDetailedStats</code> and <code>AK::TempAllocInitSettings::bDebugEnableSentinels</code> are enabled by default in order to improve tracking of usage statistics, and to provide some easy detection of buffer overruns. Disable these options when the highest performance, or most accurate profiling data, is required for your application. Support for these options is removed entirely in the Release configuration of the sound engine. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>

