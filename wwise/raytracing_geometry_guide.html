<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Raytracing Engine Geometry Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Raytracing Engine Geometry Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="raytracing_geometry_guide_introduction"></a>
Introduction</h1>
<p>Raytracing is a technique for efficiently evaluating nth-order reflection and diffraction. The basic idea is to randomly cast rays from the listener and follow their paths through a series of reflections and diffraction. The technique is inspired by graphic rendering techniques. Maximum Reflection order [1-4] and diffraction order [1-8] values are defined in the <code><a class="el" href="struct_ak_spatial_audio_init_settings.html" title="Initialization settings of the spatial audio module.">AkSpatialAudioInitSettings</a></code> structure of <code><a class="el" href="_ak_spatial_audio_8h.html">AkSpatialAudio.h</a></code>. Refer to <a class="el" href="struct_ak_spatial_audio_init_settings.html">AkSpatialAudioInitSettings</a> for more details.</p>
<div class="image">
<img src="Ray_Casting.png" alt=""/>
</div>
<h1><a class="anchor" id="raytracing_geometry_guide_concepts"></a>
Concepts</h1>
<ul>
<li>Primary rays: the rays directly cast from the listener</li>
<li>Reflection: bouncing of sound on surfaces</li>
<li>Diffraction: bending of sound around objects</li>
<li>Paths: series of reflections/diffractions from the listener to an emitter</li>
</ul>
<h1><a class="anchor" id="raytracing_geometry_guide_settings"></a>
Settings</h1>
<p>In order to tweak spatial audio CPU performance and quality, the raytracing engine uses several parameters. For a detailed description of the spatial audio settings, see <a class="el" href="struct_ak_spatial_audio_init_settings.html" title="Initialization settings of the spatial audio module.">AkSpatialAudioInitSettings()</a>.</p>
<h1><a class="anchor" id="raytracing_geometry_guide_cpu_limit_mode"></a>
CPU Limit Mode</h1>
<p>Tweaking the number of primary rays can be tricky as it depends on the complexity of the scene (for example, the number of triangles and diffraction edges) and the number of emitters. When CPU Limit Mode is active, the raytracing engine automatically adapts the number of primary rays to ensure CPU usage remains around the target value defined by the user. Although this mode minimizes peaks in CPU usage it cannot completely remove short and sudden peaks. Setting a high target value increases quality (number of reflection and diffraction paths found) at the cost of performance. While setting a low target value increases performance at the cost of quality. When CPU Limit Mode is active, the number of primary rays is capped at the user-defined number of primary rays (see <a class="el" href="struct_ak_spatial_audio_init_settings.html">AkSpatialAudioInitSettings</a>). When the number of primary rays drops to 0, the raytracing engine stops scanning the environment. However, the existing sound propagation paths are still validated and updated. As a consequence, the raytracing engine still consumes CPU. Note that CPU Limit Mode doesn't have a significant effect on portal ray tracing. Portal ray tracing increases the CPU load and might therefore force the CPU Limit Mode to temporarily reduce the number of primary rays.</p>
<h1><a class="anchor" id="raytracing_geometry_guide_load_balancing"></a>
Load Balancing</h1>
<p>Load balancing provides a way to flatten CPU peaks by distributing spatial audio task computation over several frames. Spatial audio executes different types of tasks, such as ray casting and path validation, to compute the sound propagation paths (reflections and diffraction). Whenever one of these tasks needs to be performed, it is placed in a priority queue for further processing instead of being executed immediately. The tasks in the queue are then executed over the number of frames specified in the load balancing spread setting.</p>
<h2><a class="anchor" id="raytracing_geometry_guide_load_balancing_use_cases"></a>
Load Balancing Use Cases</h2>
<p>There are several ways to tweak spatial audio performance: you can apply a CPU limit, change the order of reflection, enable or disable diffraction and diffraction on reflections, and adjust the motion threshold setting. You can combine load balancing with the other settings to achieve the desired balance between quality and performance.</p>
<p>Although load balancing can be used in any scenario, it is most appropriate for scenes that involve multiple active emitters. Load balancing behavior is controlled through the AkSpatialAudioInitSettings::uLoadBalancingSpread setting (see <a class="el" href="struct_ak_spatial_audio_init_settings.html">AkSpatialAudioInitSettings</a>). A spread of 1 frame is equivalent to disabling the feature, because every task is executed immediately. Higher values increase CPU performance, but can lead to less accurate results. For example, a spread of 4 frames for a frame buffer of 1024 samples (around 21ms at 48kHz) executes the tasks over a period of 84 ms. Spread values under 10 should not noticeably affect quality.</p>
<h2><a class="anchor" id="raytracing_geometry_guide_load_balancing_examples"></a>
Load Balancing Example</h2>
<p>The following example compares the performance in the same scene with three different spread values: 1 (disable), 4, and 10. The scene has 944 triangles and 649 diffraction edges. The number of emitters is 4. Reflection order is set to 4 and diffraction is enabled.</p>
<div class="image">
<img src="tinyCity3DView.png" alt=""/>
<div class="caption">
An urban environment with several emitters.</div></div>
<p>The following table shows the effect of different load balancing values on the scene.</p>
<table border="1" cellspacing="0" cellpadding="1" width="800px">
<tr>
<th>Spread</th><th>Average CPU %</th><th>Max CPU % </th></tr>
<tr>
<td>Disabled </td><td>4.8 </td><td>52.76  </td></tr>
<tr>
<td>4 </td><td>3.16 </td><td>23.26  </td></tr>
<tr>
<td>10 </td><td>1.71 </td><td>10.22  </td></tr>
</table>
<p><br  />
</p>
<div class="image">
<img src="LoadBalancing1.png" alt=""/>
<div class="caption">
With load balancing disabled, the number of emitters in a frame can go up to 4, which leads to high CPU peaks.</div></div>
<p> <br  />
</p>
<div class="image">
<img src="LoadBalancing4.png" alt=""/>
<div class="caption">
With a spread of 4, a maximum of 2 emitters are processed in a given frame, which lowers the CPU peaks.</div></div>
<p> <br  />
</p>
<div class="image">
<img src="LoadBalancing10.png" alt=""/>
<div class="caption">
With a spread of 10, only 1 emitter is processed in a given frame, which reduces CPU peaks even more.</div></div>
<p> <br  />
</p>
<h2><a class="anchor" id="raytracing_geometry_guide_load_balancing_FAQ"></a>
Load Balancing FAQ</h2>
<ul>
<li>
<p class="startli">Does load balancing cause delays?</p>
<p class="interli">Not exactly. It can introduce a "delay" in updating path information, but does not add latency to the audio signal. For instance, the same rays might be used until the next update. The paths are still computed at each frame, but are not validated at each frame. This means that some paths might be less accurate. For instance, specular reflection positions might be slightly inaccurate.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Does the load balancing improve the average CPU performance?</p>
<p class="interli">Although load balancing primarily focuses on decreasing CPU peaks, it can also decrease CPU averages because it prevents the same type of task from appearing in the queue multiple times. If a task is in the queue, it must be executed before another task of the same type can be added to the queue.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Does load balancing improve CPU performance when there is only one emitter?</p>
<p class="interli">Not significantly. Path validation is the most CPU-intensive spatial audio task. Given that one path validation task is executed for each emitter, load balancing is more appropriate for situations that involve several emitters. However, it can slightly improve single-emitter scenarios by preventing redundant computations.</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="raytracing_geometry_guide_load_balancing_in_depth"></a>
Load Balancing in Depth</h2>
<p>Whenever a spatial audio task needs to be performed, it is placed in a priority queue for further processing instead of being executed immediately. If the task is already in the queue, it is not placed in the queue again. This prevents redundant computation and reduces CPU consumption. At each frame, the number of tasks to process (N) is computed based on the number of elements in the queue and the load balancing spread settings. The first N priority tasks are pulled from the queue and executed.</p>
<p>In general, task priority is determined by the time at which the task was created (inserted): older tasks are executed first. For some tasks, such as the path validation tasks, the priority might be different. Whenever an emitter becomes active, the path validation task priority is increased to force the validation of the new paths. This is important to prevent delays in path creation.</p>
<div class="image">
<img src="LoadBalancingPushToQueue.png" alt=""/>
<div class="caption">
A task is placed in the queue if it is not already scheduled.</div></div>
<p> <br  />
</p>
<div class="image">
<img src="LoadBalancingPopFromQueue.png" alt=""/>
<div class="caption">
At each frame, N tasks are pulled from the queue for execution.</div></div>
<p> <br  />
</p>
<div class="image">
<img src="LoadBalancingSpread.png" alt=""/>
<div class="caption">
There are 7 elements in the queue and the load balancing spread is set to 3. The number of tasks (N) that will be executed in this frame is CEIL(7/3) = 3. The tasks T1, T2, and T3 will be executed in the same frame. The process is repeated in the next frame.</div></div>
<h1><a class="anchor" id="raytracing_geometry_guide_limitations"></a>
Limitations</h1>
<p>There are a few limitations when defining geometries for the raytracing engine. The limitations concern both the performance and the quality of the results.</p>
<h1><a class="anchor" id="raytracing_geometry_guide_limitations_visible_angle"></a>
Geometry visible angle</h1>
<p>When a triangle is smaller than the sampling density, the raytracing engine is less likely to find it.</p>
<p>The geometry's visible angle alpha is the angle at which the geometry is seen from the point of view of the listener. Depending on the number of primary rays, the average angle (gamma) between two rays varies. The relation between alpha and gamma influences the probability of finding an intersection (a reflection or a diffraction) with the object. If gamma is smaller than alpha, the probability of finding an intersection is high. If gamma is bigger than alpha, the probability of finding an intersection is low.</p>
<div class="image">
<img src="Visibility_Angle.png" alt=""/>
<div class="caption">
In this example, gamma is smaller than alpha. Hence, the probability of finding an intersection with the object is high.</div></div>
<div class="image">
<img src="Small_Visibility_Angle.png" alt=""/>
<div class="caption">
In this example, alpha is smaller than gamma. Hence, the probability of finding an intersection with the object is low.</div></div>
<h1><a class="anchor" id="raytracing_geometry_guide_limitations_number_of_triangles"></a>
Number of triangles</h1>
<p>The number of triangles contained in the geometry is directly related to the CPU usage of the engine: the more triangles, the higher the CPU usage. This is due to the fact that more intersection tests are required on the object. Usually, sound propagation does not require highly detailed geometry. Reducing the number of triangles can help increase the performance without sacrificing quality.</p>
<div class="image">
<img src="Number_Of_Triangles.png" alt=""/>
<div class="caption">
Here the plane is composed of 4 triangles: the rays have to be tested against each triangle.</div></div>
<h1><a class="anchor" id="raytracing_geometry_guide_limitations_geometry_shape"></a>
Geometry shape</h1>
<p>Some geometry shapes are more difficult to process than others. Usually, geometries like planes and boxes are simple to process and give the best results in terms of sound propagation. Spheres and cylinders are more prone to errors. This is due to the curvature introduced by the sphere and the cylinder. Some diffraction edges may not be found, which would cause some diffraction paths to be missed. The algorithm implements several heuristics to overcome this issue in most cases. Increasing the number of primary rays or simplifying the geometry can solve the issue as well.</p>
<div class="image">
<img src="Geometry_Shape.png" alt=""/>
<div class="caption">
In this situation, we expect to find the diffraction path from L to E that goes through L, E2, E3, E4, and E. Unfortunately, the surface between E1 and E2 is small and thus it is difficult to find the necessary intersection that will provide the diffraction edge E2. In this case, the intersection with E1 is more likely. L is not in the shadow zone of E1, preventing the algorithm from actually finding the diffraction path from E2.</div></div>
<h1><a class="anchor" id="raytracing_geometry_guide_performance_tweaking"></a>
Performance Tweaking</h1>
<p>The following table provides information you can use to tweak parameters for different use cases.</p>
<table border="1" cellspacing="0" cellpadding="1" width="900px">
<tr>
<th>Symptoms</th><th>Possible solutions </th></tr>
<tr>
<td>Spatial Audio - General CPU issues </td><td><ul>
<li>
<b>Decrease the order of reflection:</b> 1st and 2nd order of reflection are sufficient in most cases.  </li>
<li>
<b>Disable diffraction or reflection on diffraction if not needed:</b> computing diffraction is CPU intensive. Instead of completely disabling diffraction, reduce the number of diffraction edges in the scene if possible.  </li>
<li>
<b>Use rooms and portals:</b> if your scene is composed of independent sections, consider using rooms and portals to isolate them. <br  />
  </li>
<li>
<b>Increase the motion threshold:</b> small values might validate reflection and diffraction paths too often. Consider setting this to the highest possible value that maintains good quality results. Low values might introduce some inaccuracy in the reflection and diffraction paths. Some examples of inaccuracy: reflections might not be perfectly specular, some paths might be discovered with some delay, some invalid paths might be removed later than expected.  </li>
<li>
<b>Decrease the number of triangles if possible:</b> objects with a high level of detail increase CPU cost and tend to decrease overall quality.  </li>
</ul>
</td></tr>
<tr>
<td>Spatial Audio - Raytracing CPU is high </td><td><ul>
<li>
<b>Decrease the number of primary rays:</b> values as low as 5 can still produce good results.  </li>
<li>
<b>Enable CPU limit (CPU Limit Mode):</b> set your desired CPU percentage, and the feature will automatically control the number of primary rays to keep the CPU around the specified value. Note that this will have no effect on portal ray tracing.  </li>
</ul>
</td></tr>
<tr>
<td>Spatial Audio - Path Validation CPU is high and there is only one emitter </td><td><ul>
<li>
<b>Disable diffraction or reflection on diffraction if not needed:</b> computing diffraction is CPU intensive. Instead of completely disabling diffraction, reduce the number of diffraction edges in the scene if possible.  <br  />
 </li>
</ul>
</td></tr>
<tr>
<td>Spatial Audio - Path Validation CPU is high and there are multiple emitters </td><td><ul>
<li>
<b>Enable load balancing:</b> start with a value lower than 10 and adjust if necessary. Values lower than 10 should not noticeably affect quality.  <br  />
 </li>
</ul>
</td></tr>
<tr>
<td>Spatial Audio - CPU is high (path validation and ray tracing are both involved) and there is only one emitter </td><td><ul>
<li>
<b>Enable load balancing:</b> use a value of 2. It will spread the computation of ray tracing and path validation on different frames and thus reduce the peaks. Higher values won't help much.  </li>
<li>
<b>Increase the motion threshold:</b> in this case, it reduces average CPU consumption more than it reduces the peaks.  <br  />
 </li>
</ul>
</td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>

