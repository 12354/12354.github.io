<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Optimizing CPU usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Optimizing CPU usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="eventmgrthread"></a>
Audio Rendering Thread</h1>
<p>By default, the Wwise Sound Engine does all its command processing and audio rendering in a dedicated thread named <code>AK::EventManager</code>, controlled by the AkPlatformInitSettings::threadLEngine parameters. Calling <code>AK::SoundEngine::RenderAudio</code> signals the end of a game frame and allows the thread to consume all API commands received since the previous call to <code>RenderAudio</code>.</p>
<p>Setting <code>AkInitSettings::bUseLEngineThread</code> to <code>false</code> disables this thread and causes <code>RenderAudio</code> to run synchronously: processing commands and, if needed, rendering audio. The actual rate of audio output remains controlled by the audio endpoint. If the <code>RenderAudio</code> call interval is shorter than the buffer period determined by <code>AkInitSettings::uNumSamplesPerFrame</code> and the output sample rate, some calls to <code>RenderAudio</code> will skip the audio rendering portion. Conversely, if the <code>RenderAudio</code> call interval is longer than the output buffer period, <code>RenderAudio</code> may process more than one buffer at a time, causing a CPU usage spike, and may eventually cause the audio to stutter.</p>
<p>Enabling offline rendering disables asynchronous command processing and audio rendering from the audio thread. The amount of audio rendered per call to <code>RenderAudio</code> is determined by a positive non-zero value sent to <code>AK::SoundEngine::SetOfflineRenderingFrameTime</code>. A zero or negative value will force <code>RenderAudio</code> to process precisely one audio buffer.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Caution.gif" alt="" class="inline"/></td><td><b>Caution:</b> With the audio rendering thread disabled or with offline rendering enabled, synchronous <code>AK::SoundEngine::LoadBank</code> and <code>AK::SoundEngine::UnloadBank</code> API calls must <b>not</b> be made from the same thread as the caller of <code>RenderAudio</code>. This is because these calls may block until an audio buffer is rendered to complete Stop operations and free SoundBank media, which won't happen without a concurrent call to <code>RenderAudio</code>. </td></tr>
</table>
<p>On <a class="el" href="namespace_microsoft.html">Microsoft</a> platforms, due to the use of a single-threaded apartment (STA) concurrency model, <code>CoInitializeEx()</code> must be called from the same thread that calls <code>AK::SoundEngine::RenderAudio</code> when setting <code>AkInitSettings::bUseLEngineThread</code> to <code>false</code>.</p>
<h1><a class="anchor" id="eventmgrthread_query_functions"></a>
Using Query API Functions</h1>
<p>Certain <a class="el" href="namespace_a_k_1_1_sound_engine_1_1_query.html">AK::SoundEngine::Query</a> functions can cause CPU spikes. To minimize wasted CPU time and ensure optimal performance, we recommend that you follow these guidelines:</p><ul>
<li>Use the Query functions in development builds and avoid using them in production builds.</li>
<li>If it is necessary to use Query functions, use them inside SoundEngine global callbacks (see AkGlobalCallbackLocation). For example, if you have to read RTPC values, put the code in AkGlobalCallbackLocation_BeginRender or AkGlobalCallbackLocation_EndRender.</li>
</ul>
<h1><a class="anchor" id="eventmgrthread_jobmgr"></a>
Leveraging the Job Manager for Concurrent Execution of Audio Rendering Jobs</h1>
<p>By default, the Wwise Sound Engine executes its various audio rendering tasks, or "jobs", on the audio rendering thread in a sequential fashion. These jobs include, but are not limited to, bus and voice processing tasks.</p>
<p>Concurrent execution of these audio jobs can be enabled by specifying a callback that allows the Wwise Sound Engine to request CPU time on game-managed threads. When the game provides an implementation for this callback via <code>AkJobMgrSettings::fnRequestJobWorker</code>, concurrent execution is enabled in the Wwise Sound Engine.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> When enabling concurrent job execution, some <a class="el" href="namespace_a_k_1_1_sound_engine.html">AK::SoundEngine</a> callbacks will be generated from concurrent job worker threads. Additionally, some plug-ins may not be compatible with concurrent job execution. </td></tr>
</table>
<p>To understand how the Sound Engine's Job Manager works, it is important to learn the difference between two important callbacks:</p>
<ol type="1">
<li>The <b>worker request function</b> is defined by the <em>game engine</em> and is called by the <em>Wwise Sound Engine</em>.</li>
<li>The <b>worker function</b> is defined by the <em>Wwise Sound Engine</em> and is called by the <em>game engine</em>.</li>
</ol>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> The Wwise Sound Engine expects exactly one call to the <b>worker function</b> for each worker request. For example, if the <b>worker request function</b> is called once to request three workers of type <code>AkJobType_AudioProcessing</code>, and then called again to request two workers of type <code>AkJobType_Generic</code>, then the Sound Engine will expect the game to call the <b>worker function</b> three times with <code>AkJobType_AudioProcessing</code>, and two times with <code>AkJobType_Generic</code>. The calls may be issued in any order, sequentially or concurrently from different threads. </td></tr>
</table>
<p>When the <b>worker request function</b> is defined, the audio rendering thread will behave as follows:</p>
<div class="image">
<img src="JobManagerSequenceDiagram.png" alt=""/>
<div class="caption">
Figure: Sequence Diagram of Worker Execution</div></div>
<ol type="1">
<li>Audio rendering thread identifies jobs that can be performed on multiple threads, such as voice or bus processing.</li>
<li>Audio rendering thread calls the game's <b>worker request function</b> to request CPU time on another thread. In this step, the game engine receives the address of the <b>worker function</b> to call.</li>
<li>The game engine schedules the requests on its thread pool. A number of worker threads are woken up accordingly.</li>
<li>The game's worker threads call the <b>worker functions</b> provided by the Sound Engine in step 2.</li>
<li>Each call to the <b>worker function</b> executes at least one audio rendering job, but can execute more if they are available.</li>
<li>The audio rendering thread resumes processing as soon as all required jobs have finished executing.</li>
</ol>
<p>This process can repeat multiple times throughout one audio rendering pass, and the audio rendering thread will attempt to pipeline work as much as possible. For example, when rendering the bus graph, processing time for a given bus will be requested as soon as all inputs have finished processing, and may run independently of other busses. In this way, the Job Manager will always attempt to maximize throughput.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> The <b>worker request function</b> can be called from any thread executing Sound Engine code, and <em>must</em> be implemented in a thread-safe manner. </td></tr>
</table>
<h2><a class="anchor" id="eventmgrthread_jobmgr_scheduler"></a>
Integrating with a Game Engine's Existing Job Scheduler</h2>
<p>The Wwise Sound Engine's Job Manager is designed to work in tandem with existing job schedulers to achieve co-operative multi-tasking. Game engines that already have a job scheduler should implement the <b>worker request function</b> in a way that schedules the execution of the <b>worker function</b> within their existing job system.</p>
<p>When calling the <b>worker function</b>, the game engine's job scheduler can specify a timeout in microseconds. This is to prevent the Sound Engine from taking too much CPU time on the calling thread. Past this timeout, the <b>worker function</b> will stop and request an additional worker if more jobs were available for execution. This allows the execution of other, possibly higher-priority game engine work on this thread.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> Care must be taken when delaying the execution of the <b>worker function</b> or limiting the execution time of Sound Engine work, as this can lead to voice starvation. When integrating Sound Engine jobs into an existing job scheduler, it is recommended to treat audio rendering jobs as high-priority work. </td></tr>
</table>
<p>For game engines that don't already have a job scheduler, a sample implementation of such a scheduler is provided in the SDK samples under <code>SDK/samples/SoundEngine/Common/AkJobWorkerMgr.[h,cpp]</code>. This sample provides a great starting point for concurrent execution of audio rendering jobs. Additionally, IntegrationDemo provides code demonstrating how this sample implementation can be integrated in an actual end-user application.</p>
<h2><a class="anchor" id="eventmgrthread_jobmgr_best_practices"></a>
Best Practices When Using the Job Manager</h2>
<p>Here are a few recommendations on how best to utilize the Job Manager.</p>
<ol type="1">
<li>Do not create threads on-demand when new worker requests come in. Creating new threads is an expensive operation on most systems. Instead, pre-allocate a pre-determined number of threads before the Sound Engine is initialized, and distribute worker requests among those threads.</li>
<li>Do not use more worker threads than are necessary to achieve sufficient parallelization of Sound Engine jobs. In some cases, the overhead of requesting workers may result in lost CPU time that would be more effectively used for other tasks. As well, increasing the number of workers may increase the total amount of memory that the Sound Engine requests, due to the use of thread-local caches in memory allocators or other systems in the Sound Engine.</li>
<li>On game-engine worker threads that support execution of jobs, it is recommended to call <code>AK::MemoryMgr::InitForThread</code> and <code>AK::MemoryMgr::TermForThread</code> when initializing and terminating the threads, in order to ensure proper initialization and termination of thread-local memory resources. It is also recommended to call <code>AK::MemoryMgr::TrimForThread</code> when entering a period of inactivity after running the worker function, in order to free up any thread-local memory resources which may not be utilized again in the near future.</li>
<li>On platforms where the number of CPU cores is fixed and known in advance, set worker thread affinities so each thread stays on the same CPU core. Making sure that audio work does not move across CPU cores during execution is desirable to avoid refreshing CPU caches when a thread migrates to a different core.</li>
<li>On systems with multiple Clusters or Core Complexes (CCX), set thread affinities so worker threads and the audio rendering thread all run on the same CCX in order to improve cache coherency across cores.</li>
<li>On systems with Simultaneous Multi-Threading (SMT), set thread affinities so worker threads run on separate physical cores, instead of sharing the same core, to reduce competition on CPU resources.</li>
<li>If you wish to change the maximum number of workers that the sound engine may request without reinitializing the sound engine, you can do so with <code>AK::SoundEngine::SetJobMgrMaxActiveWorkers</code>. This can be useful to dynamically respond to changes in your title's operating conditions, or to more easily experiment and profile different configurations for multi-threaded work.</li>
</ol>
<p>The recommendations above must be weighed against the other needs of the game. The Job Manager remains a good way to increase overall throughput of the Sound Engine even if some of these recommendations are not followed.</p>
<h2><a class="anchor" id="eventmgrthread_jobmgr_memory"></a>
Optimizing Job Manager Memory Usage</h2>
<p>Running out of memory when allocating a job is considered a critical failure, as the logical flow of audio rendering would be interrupted and unable to resume. This would lead to undefined results and leaks of resources.</p>
<p>To prevent this, the Job Manager allocates slabs of memory that will be kept around and re-used until the Sound Engine is terminated. Most of these slabs are pre-allocated during Sound Engine initialization, but others may be allocated as needed.</p>
<p>You can control the size of the memory slabs, as well as how many are pre-allocated at initialization time, via <code>AkInitSettings::settingsJobManager</code>.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> If <code>AK::MemoryMgr::Malloc</code> fails to allocate a new memory slab during rendering, the Job Manager will keep re-trying the allocation until it succeeds. If you observe the Sound Engine hang during low-memory situations, increase the number of pre-allocated slabs in the initialization settings. </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>

