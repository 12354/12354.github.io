<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Migrating to 2021.1 Authoring Plug-in API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Migrating to 2021.1 Authoring Plug-in API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In Wwise 2021.1, we are introducing a new API for the Authoring part of plug-ins that brings about a number of changes. This migration guide will cover those changes and provide information to help you update your plug-in code to use this new API.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> The new Authoring Plug-in API can be found under <code>&lt;Wwise&gt;/SDK/include/AK/Wwise/Plugin</code>. </td></tr>
</table>
<h1><a class="anchor" id="plugin_21_1_migration_features"></a>
New Features</h1>
<p>In 2021.1, the plug-in API has been rewritten with a few goals in mind. The main goals are to provide a better default design that separates concerns between the backend and frontend implementations, to offer better support for backward compatibility and to minimize the requirements when creating a plug-in. These goals have been accomplished in the following ways:</p>
<ul>
<li>The backend and frontend of a plug-in are separate entities where a backend can exist for multiple frontends. In the context of Wwise, the responsibilities of the backend have to do with model management and bank generation, while the frontend deals with the graphical user interface (GUI) and providing monitoring feedback to the user. This separation also means that only the backend portion of a plug-in needs to be instantiated in the context of a command-line session, which has a positive effect on performance. If no frontend is provided, a default one is generated at runtime.</li>
<li>The <code><a class="el" href="class_a_k_1_1_wwise_1_1_i_audio_plugin.html">AK::Wwise::IAudioPlugin</a></code> class has been split into smaller interfaces that are all versioned. Plug-ins are now able to request and provide services to the Authoring application by requesting service instances and implementing specific interfaces. Because there are fewer dependencies for typical plug-ins and the Authoring application has knowledge of the interface versions used, adapters for previous versions can be implemented to support them in future Wwise versions. Also, when interfaces are no longer supported, users can be informed of unsupported plug-ins. A consequence of this design is that plug-in makers will need to update their plug-ins less often to support newer Wwise versions.</li>
<li>The Authoring plug-in API adopted an architecture that is based on a C API and does not depend on toolset and platform-specific structures such as Windows SDK <code>VARIANT</code>. Plug-in dynamic libraries expose a simple C-defined structure that, for every plug-in, describes its components and provides pointers to implementations. For convenience, a C++ API reproducing the features of the original API&#160;produces these lower-level structures at compile time.</li>
<li>Registration of plug-ins has been simplified and is now embedded in the concept of a "plug-in container", which is a structure that has descriptors of all the plug-ins of a library. Plug-in classes are added to this container and the Sound Engine portion of the plug-in is automatically registered during the construction of this global container. Only a few macros are needed to expose an Authoring plug-in: this is detailed in the Library Plug-in Container section.</li>
</ul>
<p>In addition to the aforementioned new features, some functions have been reworked for clarity.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> The Sound Engine part of the plug-in does not adopt the same design, retaining the approach of previous versions. </td></tr>
</table>
<h1><a class="anchor" id="plugin_21_1_migration_changes_removals"></a>
API Changes and Removals</h1>
<p>A few methods that were deemed obsolete were removed from the API in 2021.1. Some other methods were not removed, but reworked by renaming and/or changing their arguments to make them clearer or easier to use.</p>
<ul>
<li><code>AK::Wwise::IAudioPlugin::SetPluginPropertySet()</code> : Removed (obsolete)</li>
<li><code>AK::Wwise::IAudioPlugin::SetPluginObjectStore()</code> : Removed (obsolete)</li>
<li><code>AK::Wwise::IAudioPlugin::SetPluginObjectMedia()</code> : Removed (obsolete)</li>
<li><code>AK::Wwise::IAudioPlugin::Destroy()</code> : Removed (obsolete)</li>
<li><code>AK::Wwise::IAudioPlugin::IsPlayable()</code> : Removed (unused)</li>
<li><code>AK::Wwise::IAudioPlugin::GetPluginMediaConverterInterface()</code> : Removed. Replaced by a standalone <code>AK::Wwise::Plugin::MediaConverter</code> interface.</li>
<li><code>AK::Wwise::IAudioPlugin::CopyInto()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::InitFromInstance()</code> : Renamed, argument changed. The logic has been reversed to resemble other <code>Init</code> methods as they are mutually exclusive.</li>
<li><code>AK::Wwise::IAudioPlugin::Load()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::InitFromWorkunit()</code> : Renamed</li>
<li><code>AK::Wwise::IAudioPlugin::Delete()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::OnDelete()</code> : Renamed</li>
</ul>
<p>Not listed are methods that have had non-optional pointer arguments changed to references.</p>
<h1><a class="anchor" id="plugin_21_1_migration_porting"></a>
Porting a Simple Plug-in</h1>
<p>It is likely that your plug-in uses a subset of the features provided by the Authoring plug-in API. Each of the following sections covers the changes related to a specific feature: refer to the appropriate section based on your plug-in's usage of the API. For more advanced features of the Authoring plug-in API, refer to Common Use Cases for Requests.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> This section refers to pre-2021.1 as the "original" API, and to 2021.1 and up to the "new" API. </td></tr>
</table>
<h2><a class="anchor" id="plugin_21_1_migration_porting_audioplugin"></a>
AudioPlugin</h2>
<p>In the original API, the <code><a class="el" href="class_a_k_1_1_wwise_1_1_i_audio_plugin.html">AK::Wwise::IAudioPlugin</a></code> interface contained all the features of the Authoring plug-in API. You could simply subclass <code><a class="el" href="class_a_k_1_1_wwise_1_1_default_audio_plugin_implementation.html" title="Use this base class to quickly implement most plugin functions empty.">AK::Wwise::DefaultAudioPluginImplementation</a></code> to empty implementations for each method, but your class still had all of these unused methods defined.</p>
<p>In the new API, there is a similar <code>AK::Wwise::Plugin::AudioPlugin</code> interface, but its only method is <code>AK::Wwise::Plugin::AudioPlugin::GetBankParameters()</code>. For a simple plug-in that has typical properties being written to a SoundBank, implementing this single interface is all that is needed. Implementing this interface also serves as an indicator that the implementing class is a backend class (as opposed to a frontend class, which is covered in the Implementing a Frontend section).</p>
<p>Concretely, there are few differences between an original and a new API class:</p>
<p><b>Original API</b> </p><div class="fragment"><div class="line"><span class="comment">// MyAudioPlugin.h</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyAudioPlugin: <span class="keyword">public</span> <a class="code" href="class_a_k_1_1_wwise_1_1_default_audio_plugin_implementation.html">AK::Wwise::DefaultAudioPluginImplementation</a></div>
<div class="line">{</div>
<div class="line">  IPluginPropertySet* m_pPSet = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> Destroy()<span class="keyword"> override </span>{ <span class="keyword">delete</span> <span class="keyword">this</span>; }</div>
<div class="line">  <span class="keywordtype">void</span> SetPluginPropertySet(IPluginPropertySet* in_pPSet) <span class="keyword">override</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> GetBankParameters(<span class="keyword">const</span> <a class="code" href="struct_g_u_i_d.html">GUID</a> &amp; in_guidPlatform, <a class="code" href="class_a_k_1_1_wwise_1_1_i_write_data.html">AK::Wwise::IWriteData</a>* in_pDataWriter) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>New API</b> </p><div class="fragment"><div class="line"><span class="comment">// MyAudioPlugin.h</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyAudioPlugin : <span class="keyword">public</span> <a class="code" href="class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_audio_plugin.html">AK::Wwise::Plugin::AudioPlugin</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">bool</span> GetBankParameters(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_g_u_i_d.html">GUID</a>&amp; in_guidPlatform,</div>
<div class="line">    <a class="code" href="class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer.html">AK::Wwise::Plugin::DataWriter</a>&amp; in_dataWriter</div>
<div class="line">  ) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Notice that there is only a single method left to implement: <code>GetBankParameters</code>. The AK::Wwise::IAudioPlugin::Destroy() function is also not necessary anymore, as instantiation and destruction is completely handled by the plug-in API. The standard C++ destructor can be use to release resources.</p>
<h2><a class="anchor" id="plugin_21_1_migration_porting_propertyset"></a>
Using the Property Set</h2>
<p>You may have noticed that the function <code>AK::Wwise::IAudioPlugin::SetPluginPropertySet()</code> has been removed in the previous section's code example. Indeed, this function is not needed anymore thanks to the <code>AK::Wwise::Plugin::AudioPlugin</code> interface that <em>requests</em> the property set component for you. By subclassing <code>AK::Wwise::Plugin::RequestPropertySet</code>, the <code>AK::Wwise::Plugin::AudioPlugin</code> interface adds a <code>PropertySet</code> component requirement to the plug-in description, which will be fulfilled by the Authoring application when the plug-in is instantiated. It also adds a member variable <code>m_propertySet</code> that will automatically be set to the <code>PropertySet</code> component instance at instantiation. This removes the need to manually create this member variable and implement its corresponding setter.</p>
<p>Implementing a simple Authoring plug-in with only <code>GetBankParameters</code> is therefore simplified:</p>
<p><b>Original API</b> </p><div class="fragment"><div class="line"><span class="comment">// MyAudioPlugin.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyAudioPlugin::SetPluginPropertySet(IPluginPropertySet* in_pPSet)</div>
<div class="line">{</div>
<div class="line">  m_pPSet = in_pPSet;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> MyAudioPlugin::GetBankParameters(<span class="keyword">const</span> <a class="code" href="struct_g_u_i_d.html">GUID</a> &amp; in_guidPlatform, <a class="code" href="class_a_k_1_1_wwise_1_1_i_write_data.html">AK::Wwise::IWriteData</a>* in_pDataWriter)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  CComVariant varProp; m_pPSet-&gt;GetValue(in_guidPlatform, L<span class="stringliteral">&quot;Placeholder&quot;</span>, varProp);</div>
<div class="line">  in_pDataWriter-&gt;WriteReal32(varProp.fltVal);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>New API</b> </p><div class="fragment"><div class="line"><span class="comment">// MyAudioPlugin.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> MyAudioPlugin::GetBankParameters(<span class="keyword">const</span> <a class="code" href="struct_g_u_i_d.html">GUID</a>&amp; in_guidPlatform, <a class="code" href="class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer.html">AK::Wwise::Plugin::DataWriter</a>&amp; in_dataWriter)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  in_dataWriter.WriteReal32(m_propertySet.GetReal32(in_guidPlatform, <span class="stringliteral">&quot;Placeholder&quot;</span>));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Some key differences:</p>
<ul>
<li>The <code>DataWriter</code> argument is now a reference, as it is not optional (cannot be NULL)</li>
<li>The property set is accessed through the inherited member variable <code>m_propertySet</code></li>
<li>The character string for the property name passed to the <code>AK::Wwise::Plugin::PropertySet::GetReal32()</code> is of type <code>const char*</code>, instead of <code>LPCWSTR</code> (const wchar_t*).</li>
<li>The type of the property (here, Real32) is specified explicitly in the method signature of the <code>AK::Wwise::Plugin::PropertySet</code> accessors for consistency with <code>AK::Wwise::Plugin::DataWriter</code>.</li>
</ul>
<p>All of these changes make implementing this function simpler, safer and more portable.</p>
<h2><a class="anchor" id="plugin_21_1_migration_porting_backend_frontend"></a>
Implementing a Frontend</h2>
<p>Implementing <code>AK::Wwise::Plugin::AudioPlugin</code> provides the minimum implementation for SoundBank generation. However, providing only this part of the plug-in means there is no custom GUI to display, and so the Authoring application will generate one that looks similar to the Multi-Editor view.</p>
<p>As previously hinted, the <code>AudioPlugin</code> class represents the backend of the Authoring plug-in: it can be used in a command-line context (without a GUI) and implements any custom data or state management. To display a custom GUI, a new class needs to be created that will be attached to the same plug-in identifier. This class will be instantiated separately from the backend class.</p>
<p>The frontend class is implemented by subclassing a frontend interface. Due to the nature of GUIs, these are permitted to be platform specific. Hence, the <code>AK::Wwise::Plugin::GUIWindows</code> interface, to which the original frontend-related methods were moved, can be subclass for providing a custom plug-in GUI on Windows.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyFrontend : <span class="keyword">public</span> <a class="code" href="class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_g_u_i_windows.html">AK::Wwise::Plugin::GUIWindows</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">bool</span> GetDialog(</div>
<div class="line">    AK::Wwise::Plugin::eDialog in_eDialog,</div>
<div class="line">    uint32_t&amp; out_uiDialogID,</div>
<div class="line">    <a class="code" href="struct_a_k_1_1_wwise_1_1_plugin_1_1_populate_table_item.html">AK::Wwise::Plugin::PopulateTableItem</a>*&amp; out_pTable</div>
<div class="line">  ) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> WindowProc(</div>
<div class="line">    AK::Wwise::Plugin::eDialog in_eDialog,</div>
<div class="line">    HWND in_hWnd,</div>
<div class="line">    uint32_t in_message,</div>
<div class="line">    WPARAM in_wParam,</div>
<div class="line">    LPARAM in_lParam,</div>
<div class="line">    LRESULT&amp; out_lResult</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> Help(</div>
<div class="line">    HWND in_hWnd,</div>
<div class="line">    AK::Wwise::Plugin::eDialog in_eDialog,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* in_szLanguageCode</div>
<div class="line">  );</div>
<div class="line">};</div>
</div><!-- fragment --><table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><b>Note:</b> If you intend to use MFC, you should also subclass <code><a class="el" href="class_a_k_1_1_wwise_1_1_plugin_1_1_plugin_m_f_c_windows.html" title="Initializes MFC for this plug-in.">AK::Wwise::Plugin::PluginMFCWindows</a></code> first. This will handle the initialization of a global <code>CWinApp</code> for your library. </td></tr>
</table>
<p>Notice that copies of <code>eDialog</code> and <code>PopulateTableItem</code> have been added to the <code><a class="el" href="namespace_a_k_1_1_wwise_1_1_plugin.html">AK::Wwise::Plugin</a></code> namespace. In the case of <code>PopulateTableItem</code>, the related macros have also been updated to reflect their relation to the frontend interface:</p>
<ul>
<li><code>AK_BEGIN_POPULATE_TABLE()</code> -&gt; <code>AK_WWISE_PLUGIN_GUI_WINDOWS_BEGIN_POPULATE_TABLE()</code> </li>
<li><code>AK_POP_ITEM()</code> -&gt; <code>AK_WWISE_PLUGIN_GUI_WINDOWS_POP_ITEM()</code> </li>
<li><code>AK_END_POPULATE_TABLE()</code> -&gt; AK_WWISE_PLUGIN_GUI_WINDOWS_END_POPULATE_TABLE()</li>
</ul>
<p>See How to Bind Regular Controls to Properties for more details.</p>
<p>In a frontend class, you must <em>not</em> subclass <code>AK::Wwise::Plugin::AudioPlugin</code> or implement any backend related logic, such as property value adjustments or operations affecting the result of a SoundBank generation. The frontend should be solely responsible for displaying properties and monitoring data in a user-friendly way, and update the plug-in model based on user input.</p>
<p>If the backend does not need to make any adjustments to values supplied by the user, the frontend can simply request the <code>PropertySet</code> component by subclassing <code>AK::Wwise::Plugin::RequestPropertySet</code>. However, if the backend does any value adjustments on properties, for example to implement dynamic property ranges, this should be implemented in the backend.</p>
<p>If the backend offers some implementations that the frontend requires, it can request the<code>LinkBackend</code> service by subclassing <code>AK::Wwise::Plugin::RequestLinkBackend</code>. It will provide the frontend class with a <code>m_backend</code> instance representing the backend instance to which it is bound.</p>
<p>The reverse is also possible, where a backend class can request <code>LinkFrontend</code> by subclassing <code>AK::Wwise::Plugin::RequestLinkFrontend</code>. One big difference for <code>LinkFrontend</code> is that there can be multiple frontends for one backend: the <code>m_frontend</code> instance inherited therefore represents an array of frontends. The size of the array can be obtained by the <code>GetArray</code> method and a <code>ForEach</code> function is offered for convenience.</p>
<h1><a class="anchor" id="plugin_21_1_migration_porting_services"></a>
Common Use Cases for Requests</h1>
<p>While the <code>PropertySet</code> component request is made implicitly by the <code>AK::Wwise::Plugin::AudioPlugin</code> interface because it is typically needed in the context of <code>AK::Wwise::Plugin::AudioPlugin::GetBankParameters()</code>, other components and services are optional and can be requested manually by subclassing any of the available <code>AK::Wwise::Plugin::Request[...]</code> classes (refer to Request Components and Services). When the plug-in provides an implementation to the Authoring application, the interface is not prefixed by <code>Request</code>. For example, this is the case for <code>AK::Wwise::Plugin::Source</code>, <code>AK::Wwise::Plugin::SinkDevices</code> and <code>AK::Wwise::Plugin::PropertyDisplayName</code>.</p>
<p>The following is a list of common use cases in the original API and the corresponding services that need to be requested to obtain the same features in the new API.</p>
<h2><a class="anchor" id="plugin_21_1_migration_porting_services_monitor"></a>
Monitoring Data</h2>
<p>Monitoring data sent by the Sound Engine counter-part of the plug-in is received through the <code>NotifyMonitorData</code> method. This method has been moved to a notification interface. Subclass <code>AK::Wwise::Plugin::Notifications::Monitor</code> to implement this method.</p>
<p>Refer to Monitoring in Authoring for details on implementing the <code>AK::Wwise::Plugin::Notifications::Monitor</code> interface.</p>
<h2><a class="anchor" id="plugin_21_1_migration_porting_services_license"></a>
Plug-in License</h2>
<p>In the original API, to provide a custom handler for licensing you had to implement <code>AK::Wwise::IAudioPlugin::GetLicenseStatus</code>. This function has been moved to a separate interface: subclass <code>AK::Wwise::Plugin::License</code> to implement this method.</p>
<p>Refer to Managing Licenses for details on how to implement <code>AK::Wwise::Plugin::License</code>.</p>
<h2><a class="anchor" id="plugin_21_1_migration_porting_services_media"></a>
Object Media and Media Converter</h2>
<p>Plug-in data meant to be handled as media, typically audio files that can be encoded during a source conversion process, could be supported by implementing <code>AK::Wwise::IAudioPlugin::SetPluginObjectMedia()</code> and <code>AK::Wwise::IAudioPlugin::GetPluginMediaConverterInterface()</code>. These, along with the management of media objects, have been centralized in the <code>AK::Wwise::Plugin::ObjectMedia</code>. Object media methods are implemented directly inside the plug-in class. The media converter, which is still optional, is a separate interface to implement: <code>AK::Wwise::Plugin::MediaConverter</code>.</p>
<p>Refer to <a class="el" href="effectplugin_media.html">Adding Media to an Audio Plug-in</a> for details on how to use these interfaces.</p>
<h2><a class="anchor" id="plugin_21_1_migration_porting_services_custom_data"></a>
Custom Plug-in Data</h2>
<p>All plug-in data that are not managed through the PropertySet or ObjectMedia components have been centralized in a common interface <code>AK::Wwise::Plugin::CustomData</code>. While most methods are the same, <code>CopyInto</code> has been reworked to reverse its logic.</p>
<ul>
<li><code>AK::Wwise::IAudioPlugin::GetPluginData()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::GetPluginData()</code> </li>
<li><code>AK::Wwise::IAudioPlugin::InitToDefault()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::InitToDefault()</code> </li>
<li><code>AK::Wwise::IAudioPlugin::CopyInto()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::InitFromInstance()</code> </li>
<li><code>AK::Wwise::IAudioPlugin::Load()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::InitFromWorkunit()</code> </li>
<li><code>AK::Wwise::IAudioPlugin::Save()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::Save()</code> </li>
<li><code>AK::Wwise::IAudioPlugin::Delete()</code> -&gt; <code>AK::Wwise::Plugin::CustomData::OnDelete()</code> </li>
</ul>
<p>The three <code>Init</code> functions are mutually exclusive: one of them will be called when the plug-in is initialized depending on the context where it is loaded.</p>
<p>Subclass the <code>AK::Wwise::Plugin::CustomData</code> interface to implement these methods. Refer to Providing Custom Data for details on how to implement the <code>CustomData</code> interface.</p>
<table border="0" cellspacing="0" cellpadding="2">
<tr>
<td valign="top"><img src="images/Note.gif" alt="" class="inline"/></td><td><p class="starttd"><b>Note:</b> <code>AK::Wwise::Plugin::CustomData::InitFromInstance()</code> initializes its instance from its argument, as opposed to initializing the provided instance in the original API through <code>AK::Wwise::IAudioPlugin::CopyInto()</code>.</p>
<p class="endtd">Make sure to apply this logic reversal when porting a plug-in using Custom Data to the 2021.1 Authoring Plug-in API. </p>
</td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespace_a_k_1_1_wwise_1_1_plugin_a5a9328b141630d1de228c92e81e9034d_html_a5a9328b141630d1de228c92e81e9034d"><div class="ttname">AK.Wwise::Plugin::eDialog</div><div class="ttdeci">eDialog</div><div class="ttdef"><b>Definition:</b> PluginDef.h:137</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_i_plugin_base_acc70ad817dcac6d8c0b52697016ae83c_html_acc70ad817dcac6d8c0b52697016ae83c"><div class="ttname">AK.Wwise::IPluginBase::Destroy</div><div class="ttdeci">virtual void Destroy()=0</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer_html"><div class="ttname"><a href="class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer.html">AK.Wwise::Plugin::V1::DataWriter</a></div><div class="ttdoc">Interface used to write data during sound bank generation.</div><div class="ttdef"><b>Definition:</b> HostDataWriter.h:245</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_g_u_i_windows_a21b81136769b185c244ada93e6767f14_html_a21b81136769b185c244ada93e6767f14"><div class="ttname">AK.Wwise::Plugin::V1::GUIWindows::GetDialog</div><div class="ttdeci">virtual bool GetDialog(eDialog in_eDialog, uint32_t &amp;out_uiDialogID, PopulateTableItem *&amp;out_pTable) const</div><div class="ttdoc">Retrieves the plug-in dialog parameters.</div><div class="ttdef"><b>Definition:</b> GUIWindows.h:280</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_i_write_data_html"><div class="ttname"><a href="class_a_k_1_1_wwise_1_1_i_write_data.html">AK.Wwise::IWriteData</a></div><div class="ttdef"><b>Definition:</b> Utilities.h:208</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_default_audio_plugin_implementation_a6376b06165c934393333f48f30cbaa7a_html_a6376b06165c934393333f48f30cbaa7a"><div class="ttname">AK.Wwise::DefaultAudioPluginImplementation::GetBankParameters</div><div class="ttdeci">virtual bool GetBankParameters(const GUID &amp;in_guidPlatform, IWriteData *in_pDataWriter) const</div><div class="ttdef"><b>Definition:</b> AudioPlugin.h:636</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer_a8d9b58e2ecba7f95721d4b89b7f9630f_html_a8d9b58e2ecba7f95721d4b89b7f9630f"><div class="ttname">AK.Wwise::Plugin::V1::DataWriter::WriteReal32</div><div class="ttdeci">bool WriteReal32(float in_value)</div><div class="ttdoc">Writes a 32-bit, single-precision floating point value.</div><div class="ttdef"><b>Definition:</b> HostDataWriter.h:427</div></div>
<div class="ttc" id="astruct_a_k_1_1_wwise_1_1_plugin_1_1_populate_table_item_html"><div class="ttname"><a href="struct_a_k_1_1_wwise_1_1_plugin_1_1_populate_table_item.html">AK.Wwise::Plugin::PopulateTableItem</a></div><div class="ttdef"><b>Definition:</b> PluginDef.h:126</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_g_u_i_windows_a4923a0688cfc1bca88fcd33196c897a7_html_a4923a0688cfc1bca88fcd33196c897a7"><div class="ttname">AK.Wwise::Plugin::V1::GUIWindows::Help</div><div class="ttdeci">virtual bool Help(HWND in_hWnd, eDialog in_eDialog, const char *in_szLanguageCode) const</div><div class="ttdoc">Called when the user clicks on the '?' icon.</div><div class="ttdef"><b>Definition:</b> GUIWindows.h:323</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_default_audio_plugin_implementation_html"><div class="ttname"><a href="class_a_k_1_1_wwise_1_1_default_audio_plugin_implementation.html">AK.Wwise::DefaultAudioPluginImplementation</a></div><div class="ttdoc">Use this base class to quickly implement most plugin functions empty.</div><div class="ttdef"><b>Definition:</b> AudioPlugin.h:620</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_g_u_i_windows_html"><div class="ttname"><a href="class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_g_u_i_windows.html">AK.Wwise::Plugin::V1::GUIWindows</a></div><div class="ttdoc">Windows frontend plug-in API for Audio plug-ins.</div><div class="ttdef"><b>Definition:</b> GUIWindows.h:200</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_audio_plugin_html"><div class="ttname"><a href="class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_audio_plugin.html">AK.Wwise::Plugin::V1::AudioPlugin</a></div><div class="ttdoc">Wwise API for general Audio Plug-in's backend.</div><div class="ttdef"><b>Definition:</b> AudioPlugin.h:133</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_g_u_i_windows_a8ea33835cc026463f2f64b4327f89b17_html_a8ea33835cc026463f2f64b4327f89b17"><div class="ttname">AK.Wwise::Plugin::V1::GUIWindows::WindowProc</div><div class="ttdeci">virtual bool WindowProc(eDialog in_eDialog, HWND in_hWnd, uint32_t in_message, WPARAM in_wParam, LPARAM in_lParam, LRESULT &amp;out_lResult)</div><div class="ttdoc">Window message handler for dialogs.</div><div class="ttdef"><b>Definition:</b> GUIWindows.h:303</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_default_audio_plugin_implementation_ab00d06e8aa664a4064a95f4eddc7afa0_html_ab00d06e8aa664a4064a95f4eddc7afa0"><div class="ttname">AK.Wwise::DefaultAudioPluginImplementation::SetPluginPropertySet</div><div class="ttdeci">virtual void SetPluginPropertySet(IPluginPropertySet *in_pPSet)</div><div class="ttdef"><b>Definition:</b> AudioPlugin.h:622</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_audio_plugin_ae59a3955718ed3bbde0521da21cd8539_html_ae59a3955718ed3bbde0521da21cd8539"><div class="ttname">AK.Wwise::Plugin::V1::AudioPlugin::GetBankParameters</div><div class="ttdeci">virtual bool GetBankParameters(const GUID &amp;in_guidPlatform, DataWriter &amp;in_dataWriter) const</div><div class="ttdoc">Obtains parameters that will be written to a bank.</div><div class="ttdef"><b>Definition:</b> AudioPlugin.h:228</div></div>
<div class="ttc" id="aclass_a_k_1_1_wwise_1_1_i_write_data_a1ceb7b990ac308395a13ff2d3374af7c_html_a1ceb7b990ac308395a13ff2d3374af7c"><div class="ttname">AK.Wwise::IWriteData::WriteReal32</div><div class="ttdeci">virtual bool WriteReal32(float in_fReal32)=0</div></div>
<div class="ttc" id="astruct_g_u_i_d_html"><div class="ttname"><a href="struct_g_u_i_d.html">GUID</a></div><div class="ttdef"><b>Definition:</b> PluginHelpers.h:45</div></div>
</body>
</html>

