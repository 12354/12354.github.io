<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AK::StreamMgr::IAkLowLevelIOHook::BatchCancel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_k.html">AK</a></li><li class="navelem"><a class="el" href="namespace_a_k_1_1_stream_mgr.html">StreamMgr</a></li><li class="navelem"><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook.html">IAkLowLevelIOHook</a></li>  </ul>
</div>
</div><!-- top -->
<div class="contents">
<table cellspacing="0" cellpadding="0" border="0">
  <tr>
   <td valign="top">
      <div class="navtab">
        <table>
          <tr><td class="navtab"><a class="qindexHL" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a0abfde848b599b5e5b8e8ed63dc8b555.html#a0abfde848b599b5e5b8e8ed63dc8b555">BatchOpen</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a9bc325405bc17c0a5105d0a53981b186.html#a9bc325405bc17c0a5105d0a53981b186">BatchRead</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8f5041a24e395784437a62cdd2140505.html#a8f5041a24e395784437a62cdd2140505">BatchWrite</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a7a50a7a5fa624691d7bb7608753dc096.html#a7a50a7a5fa624691d7bb7608753dc096">Close</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a5018552d455ddc2a95b727fc543aac9e.html#a5018552d455ddc2a95b727fc543aac9e">GetBlockSize</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a885d39fdd78da3748f78e176615fb6ea.html#a885d39fdd78da3748f78e176615fb6ea">GetDeviceData</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a06860cb1211c2ebd5c49f4429cc66a0b.html#a06860cb1211c2ebd5c49f4429cc66a0b">GetDeviceDesc</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a40d53d28e4c8942d23ba011f1222d29a.html#a40d53d28e4c8942d23ba011f1222d29a">OutputSearchedPaths</a></td></tr>
          <tr><td class="navtab"><a class="qindex" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a35a38687a6a0fc6431c8dc8317f2434f.html#a35a38687a6a0fc6431c8dc8317f2434f">~IAkLowLevelIOHook</a></td></tr>
        </table>
      </div>
   </td>
   <td valign="top" class="mempage">
<a id="a8bf725ab34b0dcfe959cc42f0c3e373c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf725ab34b0dcfe959cc42f0c3e373c">&#9670;&nbsp;</a></span>BatchCancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AK::StreamMgr::IAkLowLevelIOHook::BatchCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce">AkUInt32</a>&#160;</td>
          <td class="paramname"><em>in_uNumTransfers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_1_1_batch_io_transfer_item.html">BatchIoTransferItem</a> *&#160;</td>
          <td class="paramname"><em>in_pTransferItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool **&#160;</td>
          <td class="paramname"><em>io_ppbCancelAllTransfersForThisFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies that a transfer request is cancelled. It will be flushed by the streaming device when completed. Cancellation is normal and happens regularly; for example, whenever a sound stops before the end or stops looping. It happens even more frequently when buffering (<a class="el" href="struct_ak_device_settings_af396c1626da7df1bbb6d9129e132b02f.html#af396c1626da7df1bbb6d9129e132b02f" title="Targetted automatic stream buffer length (ms). When a stream reaches that buffering,...">AkDeviceSettings::fTargetAutoStmBufferLength</a> and <a class="el" href="struct_ak_device_settings_abd4879bfd150b9a2f898102e3815dbe2.html#abd4879bfd150b9a2f898102e3815dbe2" title="I/O requests granularity (typical bytes/request).">AkDeviceSettings::uGranularity</a>) is large and when you low-level IO hook accepts many concurrent requests at the same time. </p><dl class="section remark"><dt>Remarks</dt><dd><ul>
<li><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a> is an optional functionality that can be implemented as a no-op.</li>
<li><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a> simply informs the Low-Level I/O that a specific transfer will be flushed upon reception. The Low-Level I/O may use this information to stop this transfer right away, or not (it is internally tagged by the high-level device as cancelled). Nevertheless, the callback function MUST be called for cancelled transfers to be resolved.</li>
<li>When calling the callback function of a cancelled transfer, pass it <em>AK_Success</em>. Passing AK_Fail to AkAsyncIOTransfer::pCallback has the effect of killing the stream once and for all. This is not what you want.</li>
<li>If io_bCancelAllTransfersForThisFile is set, you may cancel all transfers for this file at once. Leave io_bCancelAllTransfersForThisFile to true if you don't want to be called again. For example, if you don't do anything special in <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a>, leave it to true. This will reduce the amount of useless calls. If you set it to false, <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a> will be called again for each remaining pending transfer that need to be cancelled.</li>
<li>If io_bCancelAllTransfersForThisFile is not set, <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a> is only called for a subset of pending transfers for this file. You must not set it to true, as <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a> needs to be called explicitly for each transfer that should be cancelled. </li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>The calling thread holds the stream's lock. You may call the callback function directly from here (if you can guarantee that the I/O buffer will not be accessed in the meantime), but you must not wait here for another thread to call the callback function.</li>
<li>Likewise, if you resolve transfers with your own thread and use a lock to protect your transfers queue, be careful not to run into a deadlock. <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a> can be executed by any thread. Thus, if you need to lock your queue in <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a>, you must never hold this lock when calling back transfers, either from within <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a> or from your worker thread's routine. Lock your list, dequeue the transfer if you can, unlock, and call pCallback if and only if the transfer was found and dequeued. On the other hand, if you choose not to do anything in <a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_a8bf725ab34b0dcfe959cc42f0c3e373c.html#a8bf725ab34b0dcfe959cc42f0c3e373c">BatchCancel()</a>, the lock only protects your list between Read()/Write() and your worker thread's routine, and since the device I/O thread does not hold the stream's lock while calling Read()/Write(), your worker thread may therefore hold it while calling back transfers.</li>
<li>A race condition exists when cancelling all transfers (io_bCancelAllTransfersForThisFile is true) directly from within this hook. If you handle the io_bCancelAllTransfersForThisFile == true case, you need to defer calling the completion callback to later (from your usual I/O completion thread, for example). This will be fixed in a future version of <a class="el" href="namespace_a_k_1_1_wwise.html">Wwise</a>. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_uNumTransfers</td><td>Number of transfers to process </td></tr>
    <tr><td class="paramname">in_pTransferItems</td><td>List of transfer items to process </td></tr>
    <tr><td class="paramname">io_ppbCancelAllTransfersForThisFile</td><td>Flag for each transfer indicating whether all transfers should be cancelled for this file (see notes in function description). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
    </td>
  </tr>
</table>
</div><!-- contents -->
</body>
</html>
