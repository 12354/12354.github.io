<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AK::StreamMgr::IAkLowLevelIOHook Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="akdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wwise SDK 2023.1.0 - Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_k.html">AK</a></li><li class="navelem"><a class="el" href="namespace_a_k_1_1_stream_mgr.html">StreamMgr</a></li><li class="navelem"><a class="el" href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook.html">IAkLowLevelIOHook</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">AK::StreamMgr::IAkLowLevelIOHook Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_ak_stream_mgr_module_8h_source.html">AkStreamMgrModule.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_1_1_batch_io_transfer_item.html">BatchIoTransferItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7a50a7a5fa624691d7bb7608753dc096"><td class="memItemLeft" align="right" valign="top">virtual AKRESULT&#160;</td><td class="memItemRight" valign="bottom">Close (<a class="el" href="struct_ak_file_desc.html">AkFileDesc</a> *in_pFileDesc)=0</td></tr>
<tr class="separator:a7a50a7a5fa624691d7bb7608753dc096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5018552d455ddc2a95b727fc543aac9e"><td class="memItemLeft" align="right" valign="top">virtual AkUInt32&#160;</td><td class="memItemRight" valign="bottom">GetBlockSize (<a class="el" href="struct_ak_file_desc.html">AkFileDesc</a> &amp;in_fileDesc)=0</td></tr>
<tr class="separator:a5018552d455ddc2a95b727fc543aac9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06860cb1211c2ebd5c49f4429cc66a0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom">GetDeviceDesc (<a class="el" href="struct_ak_device_desc.html">AkDeviceDesc</a> &amp;out_deviceDesc)=0</td></tr>
<tr class="separator:a06860cb1211c2ebd5c49f4429cc66a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885d39fdd78da3748f78e176615fb6ea"><td class="memItemLeft" align="right" valign="top">virtual AkUInt32&#160;</td><td class="memItemRight" valign="bottom">GetDeviceData ()=0</td></tr>
<tr class="separator:a885d39fdd78da3748f78e176615fb6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abfde848b599b5e5b8e8ed63dc8b555"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom">BatchOpen (AkUInt32 in_uNumFiles, <a class="el" href="struct_ak_async_file_open_data.html">AkAsyncFileOpenData</a> **in_ppItems)=0</td></tr>
<tr class="separator:a0abfde848b599b5e5b8e8ed63dc8b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc325405bc17c0a5105d0a53981b186"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom">BatchRead (AkUInt32 in_uNumTransfers, <a class="el" href="struct_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_1_1_batch_io_transfer_item.html">BatchIoTransferItem</a> *in_pTransferItems)=0</td></tr>
<tr class="separator:a9bc325405bc17c0a5105d0a53981b186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5041a24e395784437a62cdd2140505"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom">BatchWrite (AkUInt32 in_uNumTransfers, <a class="el" href="struct_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_1_1_batch_io_transfer_item.html">BatchIoTransferItem</a> *in_pTransferItems)=0</td></tr>
<tr class="separator:a8f5041a24e395784437a62cdd2140505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf725ab34b0dcfe959cc42f0c3e373c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom">BatchCancel (AkUInt32 in_uNumTransfers, <a class="el" href="struct_a_k_1_1_stream_mgr_1_1_i_ak_low_level_i_o_hook_1_1_batch_io_transfer_item.html">BatchIoTransferItem</a> *in_pTransferItems, bool **io_ppbCancelAllTransfersForThisFile)=0</td></tr>
<tr class="separator:a8bf725ab34b0dcfe959cc42f0c3e373c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d53d28e4c8942d23ba011f1222d29a"><td class="memItemLeft" align="right" valign="top">virtual AKRESULT&#160;</td><td class="memItemRight" valign="bottom">OutputSearchedPaths (AKRESULT in_result, const <a class="el" href="struct_ak_file_open_data.html">AkFileOpenData</a> &amp;in_FileOpen, AkOSChar *out_searchedPath, AkInt32 in_pathSize)</td></tr>
<tr class="memdesc:a40d53d28e4c8942d23ba011f1222d29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to provide information when file related errors occur. The base paths known by this IO hook should be returned in out_searchedPath.  More...<br /></td></tr>
<tr class="separator:a40d53d28e4c8942d23ba011f1222d29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a35a38687a6a0fc6431c8dc8317f2434f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom">~IAkLowLevelIOHook ()</td></tr>
<tr class="memdesc:a35a38687a6a0fc6431c8dc8317f2434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor on interface to avoid warnings.  More...<br /></td></tr>
<tr class="separator:a35a38687a6a0fc6431c8dc8317f2434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for batched deferred low-level I/O transfers. This I/O transfer handshaking method is preferred when you want to hook I/O to your own I/O streaming technology, and you want to submit multiple I/O requests in one call, so as to allow for better opportunities for CPU and I/O performance. All operations in this interface will be happening in the device's own thread, separate from the main audio thread. Also, it is assumed that all operations are asynchronous although immediate resolution is also supported. You may queue them into your own system, and even use the heuristics passed down to this level for your convenience. Note that the requests are always sent in the order that the Stream Manager considers to be the most appropriate. You may receive less than AkDeviceSettings::uMaxConcurrentIO at any given time. The number of concurrent transfers depends on the number of streams running in the high-level streaming device, and on its target buffering length and granularity. Your advantage at this level is to be aware of file placement, so you may try to re-order requests in order to minimize seeking on disk. Calls to BatchRead()/BatchWrite() should return as soon as possible. You need to call AkAsyncIOTransferInfo::pCallback for all individual items in a transfer batch. Cancel() is provided in order to inform you that the streaming device will flush this transfer upon completion. You may implement it or not. In all cases, you must call the callback. </p>

<p class="definition">Definition at line 244 of file <a class="el" href="_ak_stream_mgr_module_8h_source.html">AkStreamMgrModule.h</a>.</p>
</div></div><!-- contents -->
</body>
</html>

